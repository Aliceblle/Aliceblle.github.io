<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AliceBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-06T07:34:42.311Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Alice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP三次握手及四次挥手</title>
    <link href="http://example.com/2023/11/06/tcp/"/>
    <id>http://example.com/2023/11/06/tcp/</id>
    <published>2023-11-06T06:45:55.691Z</published>
    <updated>2023-11-06T07:34:42.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#three">三次握手</a></li></ol></li><li><ol start="2"><li><a href="#four">四次挥手</a></li></ol></li><li><ol start="3"><li><a href="#http">http与https的区别</a><!-- vscode-markdown-toc-config  numbering=true  autoSave=true  /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --></li></ol></li></ul><h1 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a><a name='three'></a>什么是三次握手？</h1><p>先认识几个定义：</p><ul><li>SYN：同步序列编号，是TCP&#x2F;IP建立连接时使用的握手信号。在客户机和服务器之间建立TCP连接时，先发送的信号，客户端在接收到SYN信息时，就会在自己的段内生成一个随机值</li><li>SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。</li><li>ACK： 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。</li></ul><p>三次握手：<br>三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><ul><li><p>第一次握手([SYN], Seq &#x3D; x)<br>客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。</p></li><li><p>第二次握手([SYN,ACK], Seq &#x3D; y, ACK &#x3D; x + 1)<br>服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK &#x3D; x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq &#x3D; y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手([ACK], ACK &#x3D; y + 1)<br>客户端再次发送确认包(ACK),ACK &#x3D; y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。</p></li></ul><p><img src="/pic/tcp_1.png" alt="tcp" title="tcp"><br>可以看成生活中的打电话：</p><ul><li>小明 - 客户端 小红 - 服务端</li><li>小明给小红打电话，接通了后，小明说喂，能听到吗，这就相当于是连接建立。</li><li>小红给小明回应，能听到，你能听到我说的话吗，这就相当于是请求响应。</li><li>小明听到小红的回应后，好的，这相当于是连接确认。在这之后小明和小红就可以通话&#x2F;交换信息了</li></ul><h1 id="什么时候四次挥手？"><a href="#什么时候四次挥手？" class="headerlink" title="什么时候四次挥手？"></a><a name='four'></a>什么时候四次挥手？</h1><p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。</p><p>TCP连接的断开需要发送四个包，所以称为四次挥手。</p><ul><li><p>第一次挥手（[FIN], Seq &#x3D; x）<br>客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手 ([ACK], ACK &#x3D; x + 1)<br>服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。</p></li><li><p>第三次挥手 ([FIN], Seq &#x3D; y)<br>服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。</p></li><li><p>第四次挥手 ([ACK], ACK &#x3D; y + 1)<br>客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。<br>服务端接收到ACK包后，关闭连接，进入CLOSED状态。<br>客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。<br><img src="/pic/tcp_2.png" alt="tcp" title="tcp"></p></li></ul><p>可以看成生活中的打电话：</p><ul><li>小明 - 客户端 小红 - 服务端</li><li>小明对小红说，我所有的东西都说完了，我要挂电话了。</li><li>小红说，收到，我这边还有一些东西没说。</li><li>经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了</li><li>小明收到消息后，又等了若干时间后，挂断了电话。</li></ul><h1 id="http与https的区别？"><a href="#http与https的区别？" class="headerlink" title="http与https的区别？"></a><a name='http'></a>http与https的区别？</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。<br>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。<br>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。<br>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>而 HTTPS 的全称是 Hypertext Transfer Protocol Secure，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS&#x2F;SSL 协议组合而成，而安全性的保证正是 TLS&#x2F;SSL 所做的工作。</p><p>也就是说，HTTPS 就是身披了一层 SSL 的 HTTP。<br>那么，HTTP 和 HTTPS 的主要区别是什么呢？</p><p>最简单的，HTTP 在地址栏上的协议是以 http:&#x2F;&#x2F; 开头，而 HTTPS 在地址栏上的协议是以 https:&#x2F;&#x2F; 开头</p><pre><code class="js"> http://www.cxuanblog.com/  https://www.cxuanblog.com/ </code></pre><p>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。</p><p>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</p><h1 id="HTTP-GET-和POST的区别？"><a href="#HTTP-GET-和POST的区别？" class="headerlink" title="HTTP GET 和POST的区别？"></a>HTTP GET 和POST的区别？</h1><p>HTTP 中包括许多方法，Get 和 Post 是 HTTP 中最常用的两个方法，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。</p><p>get 方法一般用于请求，比如你在浏览器地址栏输入 <a href="http://www.cxuanblog.com/">www.cxuanblog.com</a> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于 <form> 表单的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull&#x2F;拉的操作，而 post 相当于是一个 push&#x2F;推的操作。<br>get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；</p><pre><code class="js"> /test/demo_form.asp?name1=value1&amp;name2=value2 </code></pre><p>而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><pre><code class="js"> POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 </code></pre><ul><li>get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</li><li>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</li><li>get 请求在浏览器反复的 回退&#x2F;前进 操作是无害的，而 post 操作会再次提交表单请求。</li><li>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h1&gt;&lt;!-- vscode-markdown-toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#three&quot;&gt;三</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>DOM&amp;&amp;BOM知识点梳理</title>
    <link href="http://example.com/2023/11/01/DOM/"/>
    <id>http://example.com/2023/11/01/DOM/</id>
    <published>2023-11-01T12:52:59.972Z</published>
    <updated>2023-11-03T12:06:24.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM知识点"><a href="#DOM知识点" class="headerlink" title="DOM知识点"></a>DOM知识点</h1><h2 id="DOM概念"><a href="#DOM概念" class="headerlink" title="DOM概念"></a>DOM概念</h2><p>在掘金上看到一个很好的解释-DOM</p><ul><li><p>D,代表文档<br>如果没有文档，DOM也就无从谈起，当你创建的网页加载到浏览器时，DOM在幕后就悄然而生，此时你的这个<strong>网页文档就是一个文档对象</strong>，也就是DOM中的D.</p></li><li><p>O,代表对象<br>O代表的就是宿主对象，也就是浏览器给我们提供的这部分对象。</p></li><li><p>M，代表模型<br>这里首先要知道字面的模型是什么意思？生活中我们常见的模型主要有飞机模型，汽车模型，人体模型等，不管是什么模型，他们都是某种事物的表现形式。就像飞机模型代表着一架真正的飞机，一张城市地图代表着某一座城市一样。那么，在这里的模型就指的是我们这个网页，这个网页里的各种HTML元素都是构成这个模型的组件，他们相互包含又相互并列存在，构成一种父子、兄弟的关系，也就类似于一棵树的各个分支一样，许多的分支组成了这一棵树，这棵树就是一个模型。</p></li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点概念"><a href="#节点概念" class="headerlink" title="节点概念"></a>节点概念</h3><p>一个html标签标识了整个文档的开始，这个网页里的所有其他元素都包含在这个标签当中。均可以用父子、兄弟关系来描述这样一个网页，构成这些父子兄弟的元素分隔点，我们就称其为节点。</p><h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><ul><li><p>元素节点<br>&lt;\h1&gt;、&lt;\p&gt;、&lt;\ul&gt;这些元素就被成为元素节点。</p></li><li><p>文本节点<br>在一个网页中大部分的内容都由文本来提供，如这个网页里 p 标签所包含的那段文字，他就是一个文本节点，一般网页里的文本节点总是被包含在元素节点内部，但不是所有的元素节点都包含文本节点。</p></li><li><p>属性节点<br>属性节点是元素节点的更具体描述，例如可以描述出他的类型，说明等，比如大部分元素都具备title属性，这个属性就是用来对每个元素的内容加以说明，这个节点就是属性节点。</p></li></ul><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;节点的概念&lt;/title&gt;&lt;/head&gt;&lt;body&gt;     &lt;h1&gt;这是一个标题&lt;/h1&gt;    &lt;p title=&quot;这段文字的说明&quot;&gt;这是一段文字说明，也是一个段落&lt;/p&gt;    &lt;p&gt;测试数据&lt;/p&gt;    &lt;ul id=&quot;purchases&quot;&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>1.通过元素节点的id&#x2F;class属性去获取</p><pre><code class="js">document.getElementById(id)// 语法document.getElementsByClassName(&quot;class&quot;)</code></pre><p>2.通过元素获取，它返回的是一个对象的数组</p><pre><code class="js">var Uli = document.getElementsByTagName(li)var count = Uli.lengthconsole.log(count)&gt; 4for(var i=0; i&lt;count; i++)&#123;    // 弹出四次Object,返回的是一个对象数组    alert(typeof Uli[i])&#125;</code></pre><p>3.通过css选择器获取元素</p><pre><code class="js">// 获取文档中 id=&quot;purchases&quot; 的元素：document.querySelector(&#39;#purchases&#39;)// 获取文档中第一个P元素document.querySelector(&quot;p&quot;)// 获取文档中class=&quot;sale&quot;的第一个P元素document.querySelector(&quot;p.sale&quot;)// 获取文档中有p元素有title属性的第一个p元素document.querySelector(&quot;p[title]&quot;)/**以下实例演示了多个选择器的使用方法。假定你选择了两个选择器: &lt;h2&gt; 和 &lt;h3&gt; 元素。以下代码将为文档的第一个 &lt;h2&gt; 元素添加背景颜色：**/document.querySelector(&quot;h2, h3&quot;).style.backgroundColor = &quot;red&quot;;</code></pre><h3 id="获取元素总结"><a href="#获取元素总结" class="headerlink" title="获取元素总结"></a>获取元素总结</h3><ul><li>一份文档就是一颗节点树</li><li>节点分为不同类型：元素节点，属性节点，文本节点</li><li>getElementById()返回一个对象，该对象对应着文档里的一个特定的元素节点</li><li>getElementsByTagName()和getElementsByClassName()都返回的是一个数组对象，他们分别对应着一组特定的元素节点。</li><li>每个节点都是一个对象</li><li>querySelector()可以通过css选择器，属性选择器，元素标签获取元素，返回一个特定的元素节点，拥有多个同样元素节点的只返回第一个。</li><li>querySelectorAll()返回的是一个数组对象，对应一组特定的元素节点</li></ul><h2 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h2><h3 id="getAttribute-获取属性"><a href="#getAttribute-获取属性" class="headerlink" title="getAttribute()获取属性"></a>getAttribute()获取属性</h3><pre><code class="js">Object.getAttribute(attribute)</code></pre><h3 id="setAttribute-修改元素节点的属性值"><a href="#setAttribute-修改元素节点的属性值" class="headerlink" title="setAttribute()修改元素节点的属性值"></a>setAttribute()修改元素节点的属性值</h3><p>备注：这个方法有两个参数，第一个参数是要修改的属性名，第二个是要修改的值。</p><pre><code class="js">Object.setAttribute(&quot;属相名&quot;, &quot;值&quot;)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>getElementById()    返回一个特定元素节点对象<br>getElementsByTagName()<br>getElementsByClassName()   这两个返回一组特定的数组对象<br>getAttribute()  获取属性值<br>setAttribute()  修改属性值，设置属性和值<br>querySelector() 可以通过css选择器、元素、属性获取元素，多个返回第一个<br>querySelectorAll()返回一组特定的数组对象</p><h1 id="BOM知识点"><a href="#BOM知识点" class="headerlink" title="BOM知识点"></a>BOM知识点</h1><h2 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h2><p>BOM（Browser Object Model）是浏览器对象模型，是由浏览器厂商定义的 JavaScript API 集合。BOM 可以让开发者通过 JavaScript 操作浏览器窗口和框架等浏览器相关的对象，比如 window、location、history、navigator 等对象。</p><ul><li>和DOM的区别？<br>DOM（Document Object Model）是文档对象模型，是用来描述 HTML 或 XML 文档结构的编程接口，提供了一种可操作和访问文档内容和结构的方法。DOM 主要针对文档的内容和结构进行操作，而 BOM 主要针对浏览器窗口和框架进行操作。<strong>在 DOM 和 BOM 中，最重要的对象分别是 document 和 window。</strong></li></ul><h2 id="window对象常用事件"><a href="#window对象常用事件" class="headerlink" title="window对象常用事件"></a>window对象常用事件</h2><h3 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h3><p>(1) 窗口加载<br>window.onload &#x3D; function() {}或window.addEventListener(“load”,function() {})在浏览器窗口完全加载页面时触发 load 事件，可以将需要等到页面完全加载后才执行的代码放在 load 事件中，比如操作 DOM 节点等。</p><pre><code class="js">window.onload = function() &#123;  // 页面完全加载后执行的代码&#125;;</code></pre><p>注：通过onload事件可以直接将JavaScript代码写在页面元素前面，只需使JavaScript代码在load事件后执行即可。<br>(2)DOM内容加载</p><pre><code class="js">document.addEventListener(&#39;DOMContentLoaded&#39;,function() &#123;&#125;)只加载DOM内容，不包括样式表、图片等等。(如果页面内容较多，建议使用DOMContentLoaded，免得javascript内容半天加载不出来)document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;// DOM内容完全加载后执行的代码&#125;)</code></pre><h3 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h3><p>在浏览器窗口大小发生改变时触发 resize 事件，可以通过 resize 事件调整页面布局。</p><pre><code class="js">window.onresize = function() &#123;  // 调整窗口大小后执行的代码&#125;;</code></pre><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>(1).设置定时器<br>setInterval() 和 setTimeout() 是常用的定时器方法，可以用来定时执行 JavaScript 代码。</p><pre><code class="js">// 每隔 1 秒执行一次setInterval(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 1000);// 2 秒后执行一次setTimeout(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 2000);</code></pre><p>(2)清除定时器<br>可以通过 clearInterval() 和 clearTimeout() 方法来停止定时器。</p><pre><code class="js">var a = setInterval(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 1000);// 清除定时器clearInterval(a);</code></pre><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><ul><li>概念： location属性用于获得<strong>当前窗口中加载的文档有关的信息</strong>或者设置窗体的URL，并且可以解析URL，因为返回的是一个对象，因此可以叫做location对象，还有一些导航功能，值得注意的是location既是window对象的属性，又是document对象的属性，既window.location和document.location 引用的是同一个对象。</li><li>URL: Uniform Resource Locator 统一资源定位符 :是互联网上标准的地址。互联网上的每个文件都有唯一的URL，包含 通过地址属性可以得到不同的url的信息图片location对象的属性</li></ul><pre><code class="js">location.href = “http://www.666.com”; //页面跳转到该网址location.assign(“http://www.666.com”); //页面跳转到该网址location.hash用于设置页面的标签值</code></pre><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><ul><li>概念：该对象里面保存着浏览器的各种信息，判断浏览器的各种信息就是从该对象里的属性来读取，具体属性如下</li></ul><pre><code class="js">navigator.cookicEnablcd:判断是否启用cookicnavigator.userAgent:判断浏览器的名称和版本号navigator.plugins:保存浏览器中所有插件信息的集合</code></pre><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><ul><li>概念：该对象保存着用户上网的历史记录，从窗口被打开的那一刻算起</li></ul><pre><code class="js">1.前进：history.forward();history.go(1);2.后退：history.back();history.go(-1);3.获取记录个数：history.length:</code></pre><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h2 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h2><p>参考：<a href="https://blog.csdn.net/Mozarty/article/details/130476224#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFBOM%201%20BOM%E6%A6%82%E8%BF%B0%20BOM%EF%BC%88Browser%20Object%20Model%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%82%E5%95%86%E5%AE%9A%E4%B9%89%E7%9A%84%20JavaScript%20API,%E5%9C%A8%20DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%EF%BC%8C%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E5%88%AB%E6%98%AF%20document%20%E5%92%8C%20window%E3%80%82">https://blog.csdn.net/Mozarty/article/details/130476224#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFBOM%201%20BOM%E6%A6%82%E8%BF%B0%20BOM%EF%BC%88Browser%20Object%20Model%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%82%E5%95%86%E5%AE%9A%E4%B9%89%E7%9A%84%20JavaScript%20API,%E5%9C%A8%20DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%EF%BC%8C%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E5%88%AB%E6%98%AF%20document%20%E5%92%8C%20window%E3%80%82</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DOM知识点&quot;&gt;&lt;a href=&quot;#DOM知识点&quot; class=&quot;headerlink&quot; title=&quot;DOM知识点&quot;&gt;&lt;/a&gt;DOM知识点&lt;/h1&gt;&lt;h2 id=&quot;DOM概念&quot;&gt;&lt;a href=&quot;#DOM概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="DOM" scheme="http://example.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://example.com/2023/10/30/vue/"/>
    <id>http://example.com/2023/10/30/vue/</id>
    <published>2023-10-30T11:57:56.358Z</published>
    <updated>2023-11-01T02:54:22.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue学习笔记"><a href="#vue学习笔记" class="headerlink" title="vue学习笔记"></a>vue学习笔记</h1><h2 id="初识vue"><a href="#初识vue" class="headerlink" title="初识vue"></a>初识vue</h2><ul><li>想让vue工作，必须创建一个<strong>vue实例</strong>，且要传入一个配置对象；</li><li>root容器里的代码依然符号html规范，只不过混入一个特殊的vue语法</li><li>root容器里的代码被称为【vue模板】</li><li>真实开发中只有<strong>一个</strong>vue实例，并且会配合组件一起使用；</li><li>vue实例和容器是一一对应的</li><li>中的xxx要写js的表达式，且xxx可以自动读取到data中的所有属性；</li><li>一旦data中的数据发生改变，那么页面中用到的数据地方会自动更新 </li><li>注意区分js表达式和js代码（语句）<br>1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<br>（1）a<br>（2）a+b<br>（3）demo（1）<br>（4）x&#x3D;&#x3D;&#x3D;y？‘a’：‘b’<br>2.js代码&#x2F;js语句<br>（1）if（）{}<br>（2）for（）{}</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;初始vue&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello,&#123;&#123;name&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        //创建vue实例        new Vue(&#123;            el: &#39;#root&#39;,//el用于指定当前vue实例为哪个容器服务，植通常为css选择器字符串。            data: &#123;//data用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象                name: &#39;尚硅谷123&#39;,                address: &#39;深圳&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="两类模板语法"><a href="#两类模板语法" class="headerlink" title="两类模板语法"></a>两类模板语法</h2><ul><li>插值语法：</li></ul><p>功能：用于解析标签体的内容</p><p>写法，xxx是js的表达式，且可以直接读取到data中的所有属性</p><ul><li>指令语法</li></ul><p>功能：用于解析标签（包括：标签属性，标签体内容，绑定事件。。。）</p><p>举例：v-bind：herf&#x3D;“xxx”或 简写为 ：herf&#x3D;“xxx”，xxx同样为js的表达式且可以直接读取到data中的所有属性。</p><p>备注：vue有很多指令，且都有v-…的形式</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;vue模板&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;插值语法&lt;/h1&gt;        &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt;        &lt;hr /&gt;        &lt;h1&gt;指令语法&lt;/h1&gt;        &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;        &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;jack&#39;,                school: &#123;                    name: &#39;尚硅谷&#39;,                    url: &#39;http://www.atguigu.com&#39;,                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数据绑定-2种方式"><a href="#数据绑定-2种方式" class="headerlink" title="数据绑定-2种方式"></a>数据绑定-2种方式</h2><p>1，单项数据绑定 v-bind<br>数据只能从data里面流向页面<br><img src="/pic/vue_1.png" alt="v-bind" title="v-bind"><br>2，双向数据绑定 v-model<br>数据不仅能从data流向页面，还可以从页面流向data</p><p>备注：：<br>1，双向绑定一般都引用在表单类元素上（如：input，select等）<br>2，v-model：value可以简写为v-model，因为v-model默认收集的就是value的值<br><img src="/pic/vue_2.png" alt="v-model" title="v-model"><br>3.v-bind：value简写为：value<br>4. v-model :value&#x3D;”name简写为v-model&#x3D;”name”</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        单项数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br /&gt;        双项数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br /&gt;           &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;尚硅谷&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><p>1，el的两种写法<br>（1）new Vue时候配置el属性。<br>（2）先创建Vue实例，随后再通过vm.$mount（‘#root’）指定el的值。<br>2，data有两种写法<br>（1）对象式<br>（2）函数式<br>如何选择：组件时必须使用函数式<br>3.重要原则<br>由vue管理的函数，一定不能写箭头函数，一旦写了箭头函数，this就不是vue实例了</p><pre><code class="js">&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;&lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示//el的两种写法const v = new Vue(&#123;    el:&#39;#root&#39;,//第一种    data:&#123;        name:&#39;shangguigu&#39;    &#125;&#125;)console.log(v)v.$mount(&#39;#root&#39;)//第二种    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM模型<br>1，M：模型model，data中的数据<br>2，V：视图view，模板代码<br>3，VM：视图模型viewmodel，vue实例<br>观察发现<br>1，data上的说有属性，最后都出现在vm上<br>2，vm身上的所有属性，以及vue原型上的说有属性，在vue模板中都可以直接使用</p><pre><code class="js">&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试一下：&#123;&#123;_c&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        const vm = new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;尚硅谷&#39;,                address: &#39;beijing&#39;,                a: 1            &#125;        &#125;)        console.log(vm);    &lt;/script&gt;</code></pre><p><img src="/pic/vue_3.png" alt="MVVM" title="MVVM"></p><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>1，vue中的数据代理<br>通过vm对象来代理data对象中属性的操作（读&#x2F;写）<br>2，基本原理<br>通过object。defineProperty()把对象中所有属性添加到vm上<br>为每一个添加到vm上的属性，都指定一个getter&#x2F;setter<br>在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性<br><img src="/pic/vue_4.png" alt="数据代理" title="数据代理"><br><img src="/pic/vue_5.png" alt="MVVM" title="数据代理"></p><pre><code class="js">1，    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        let number = 18        let person = &#123;            name: &#39;张三&#39;,            sex: &#39;男&#39;,        &#125;        Object.defineProperty(person, &#39;age&#39;, &#123;            value: 18,            enumerable: true,            writable: true,            configurable: true,            get() &#123;                console.log(&#39;有人读取了age属性了&#39;)                return number            &#125;,            set() &#123;                console.log(&#39;有人修改了age属性，且值式&#39;, value);                number = value            &#125;        &#125;)    &lt;/script&gt;2， &lt;!-- 数据代理：通过一个对象代理对另一个对象中的属性的操作 --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        let obj = &#123; x: 100 &#125;        let obj2 = &#123; y: 200 &#125;        Object.defineProperty(obj2, &#39;x&#39;, &#123;            get() &#123;                return obj.x            &#125;,            set(value) &#123;                obj.x = value            &#125;        &#125;)    &lt;/script&gt;3，&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;学校名称:&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        const vm = new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;atguigu&#39;,                address: &#39;jkdjhg&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue学习笔记&quot;&gt;&lt;a href=&quot;#vue学习笔记&quot; class=&quot;headerlink&quot; title=&quot;vue学习笔记&quot;&gt;&lt;/a&gt;vue学习笔记&lt;/h1&gt;&lt;h2 id=&quot;初识vue&quot;&gt;&lt;a href=&quot;#初识vue&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Web前端篇（1）</title>
    <link href="http://example.com/2023/10/27/study/"/>
    <id>http://example.com/2023/10/27/study/</id>
    <published>2023-10-27T05:08:02.221Z</published>
    <updated>2023-11-06T05:59:37.488Z</updated>
    
    <content type="html"><![CDATA[<p>嗨~这里是在网上找到的一些资料或者b站视频后整理的一些知识点，接下来会不断更新…<br>…</p><h3 id="css高频"><a href="#css高频" class="headerlink" title="css高频"></a>css高频</h3><h4 id="快速居中对齐的方式有："><a href="#快速居中对齐的方式有：" class="headerlink" title="快速居中对齐的方式有："></a>快速居中对齐的方式有：</h4><pre><code class="html">&lt;style&gt;.box&#123;display：flex;margin：auto;&#125;&lt;/style&gt;</code></pre><h4 id="margin和padding有什么不同？"><a href="#margin和padding有什么不同？" class="headerlink" title="margin和padding有什么不同？"></a>margin和padding有什么不同？</h4><p>padding是内边距，是作用于自身的，而margin是作用于外部的</p><h4 id="vw和百分比的区别？"><a href="#vw和百分比的区别？" class="headerlink" title="vw和百分比的区别？"></a>vw和百分比的区别？</h4><p>百分比有继承关系<br>vw不管父级，只和视口有关</p><h4 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>行内元素不换行，不设置大小，大小由内容决定</p><h4 id="如何让谷歌浏览器支持小字体？"><a href="#如何让谷歌浏览器支持小字体？" class="headerlink" title="如何让谷歌浏览器支持小字体？"></a>如何让谷歌浏览器支持小字体？</h4><p>通过缩放把他字体改成多少倍</p><pre><code class="css">.box&#123;transform：scale(0.8)-webkit-transform:scale(0.8)&#125;</code></pre><h3 id="js高频"><a href="#js高频" class="headerlink" title="js高频"></a>js高频</h3><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>改变原数组：</strong><br>1.pop():用于删除数组的最后一个元素<br>2.push():向数组的末尾添加一个或多个元素，并返回新的长度<br>3.shift():把数组第一个元素从其中删除，并返回第一个元素的值<br>4.unshift():向数组开头添加一个或者多个元素，并返回新长度<br>5.sort():排序<br>6.splice():添加或者删除数组中的元素<br>7.reverse():反转数组中的元素顺序<br>8.fill():讲一个固定值替换数组的元素<br>9.copeWithin():将数组元素复制到数组的另一个位置，覆盖现有值<br><strong>不改变原数组：</strong><br>一、返回新的数组<br>1.slice(): 可从已有的数组中返回选定的元素。slice 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<br>2.join():将数组作为字符串返回<br>3.toString（）：返回包含所有数组值的字符串，以逗号分隔<br>4.concat(): 用于连接两个或多个字符串。该方法没有改变原有字符串，但是会返回连接两个或多个的新数组。<br>二、返回值<br>1.indexof(): 可返回某个指定的字符串值在字符串中首次出现的位置<br>2.lastindexOf(): 可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索<br>3.include(): 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。<br><strong>遍历方法</strong><br>一、有返回值<br>1.map(): 通过指定函数处理数组的每个元素，并返回处理后的数组。<br>2.filter(): 检测数值元素，并返回符合条件所有元素的数组。<br>3.every(): 检测数值元素的每人元素是否都符合条件。<br>4.some(): 检测数组元素中是否有元素符合指定条件。<br>二、没有返回值<br>1.forEach (): 数组每个元素都执行一次回调函数。</p><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><p>1.concat()方法用于连接两个或多个字符串，该方法没有改变原有字符串，但是会返回连接两个或多个字符电新字符串<br>2.split(“”)字符串转数组<br>3.from()方法用于通过拥有length 属性的对象或可迭代的对象来返回一个数组。<br>4.slice(起始，结束) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。不会改变原始字符串<br>5.charAt()方法可返回指定位置的字符，返回值是字符串(从0开始)<br>6.replaceAll(被替换，替换）方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串<br>7.indexof()返回一个指定的字符审值最开始出现的位置，如果指定第二个参数 stat，则在一个字符串中的指定位置从前向后搜索<br>8.lastndexOf()方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 stat，则在一个字符串中的指定位置从后向前搜索，<br>9.substr()方法可在字符串中抽取从开始下标开始的指定数目的字符。<br>10.fromCharCode(65)A将 Unicode 编码转为一个字符:<br>11.toupperCase()用于把字符串转换为大写<br>12.toLowerCase()方法用于把字符串转换为小写。</p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>1obiect.freeze（）冻结对象，被冻结的对象再也不能被修改(不能添加、删除属性，冻结一个对象后的原型也不能被修改<br>2.object.getOwnropertyNames()返回一个数组，其中包含作为参数传递的对象自身属性的所有名称，包括不可枚举属性。不考虑继承属性<br>3.object.keys()获取成员是参数对象自身的(不含继承的)所有可遍历(enumerable) 属性的键名，传入对象返数组形式的属性名，数组和字符审返回对应的索引值<br>4.object.values方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable) 属性的键值，返回一个数组，其元素是在对象上找到的可枚至属性值 (value) 属性的顺序与通过手动循环对象的属性值所给出的顺序相同var obj &#x3D;{0: ‘a’ ，1:‘b’， 2 ：‘C’}；consle.log(obiectvalues obj));<br>5.Object.entries方法返回一个数组，成员是参数对象自身的(不合继承的)所有可遍历(enumerable)属性的键值对数组,obiect.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象，等同于扩展运算符。<br>6.Obiect对象的definePropertv属性标识<br>7.Object.getPrototype方法用来获取指定对象的原型<br>8.object.is()判断两值是否相同</p><h4 id="…args-扩展运算符"><a href="#…args-扩展运算符" class="headerlink" title="…args 扩展运算符"></a>…args 扩展运算符</h4><p>展开运算：允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p><h4 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h4><p> -Var<br>1）声明提升：先用后定义，无报错（（先上车后买票<br>2）没有局部作用域：在for循环之外仍可以（（红杏出墙<br>3）声明覆盖：同一个变量名被二次定义后，前面那个会被覆盖（let不行（（套牌车</p><pre><code class="js">let arr = [1,2,3]function test(a,b,c)&#123;&#125;test(..arr) //将数组展开进行传递参数</code></pre><p>数组中使用展开运算符(合并数组，类数组对象变成数组)</p><pre><code class="js">a.合并数组let arr = [1,2,3]let arr1 = [...arr,4,5,6]  //1,2,3,4,5,6</code></pre><pre><code class="js">b.展开运算符可以用于数组的一些方法中（push函数）let arr = [1,2,3]let arr1 = [4,5,6]arr1.push(...arr) //4,5,6,1,2,3</code></pre><pre><code class="js">c.类数组对象变成数组let a=new Set([1,2,3,4,5,2,1])  // a : Set(5) &#123;1, 2, 3, 4, 5&#125;let b=[...a]    //  (5) [1, 2, 3, 4, 5]</code></pre><p>3.解构赋值（解构赋值中展开运算符只能用在最后）</p><pre><code class="js">let [arg1,arg2,...arg3] = [1, 2, 3, 4] arg1 //1arg2 //2arg3 //[&#39;3&#39;,&#39;4&#39;]</code></pre><p>4.对象中的展开运算符（和数组类似）</p><pre><code class="js">let &#123;x,y,...z&#125;=&#123;x:1,y:2,a:3,b:4&#125;;x; //1y; //2z; //&#123;a:3,b:4&#125;</code></pre><pre><code class="js">let z=&#123;a:3,b:4&#125;;let n=&#123;x:1,y:2,...z&#125;;n; //&#123;x:1,y:2,a:3,b:4&#125;</code></pre><pre><code class="js">let a=&#123;x:1,y:2&#125;;let b=&#123;z:3&#125;;let ab=&#123;...a,...b&#125;;ab //&#123;x:1,y:2,z:3&#125;</code></pre><p><strong>剩余参数：</strong>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。<br>1.函数调用</p><pre><code class="js">function test(a,b,...args)&#123;&#125; //...args == [4,5,6]test(1,2,3,4,5,6)</code></pre><p>2.解构赋值（解构赋值中展开运算符只能用在最后）</p><pre><code class="js">let [arg1,arg2,...arg3] = [1, 2, 3, 4] arg1 //1arg2 //2arg3 //[&#39;3&#39;,&#39;4&#39;]</code></pre><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li>什么是浅拷贝？<br>特点：拷贝的时候只是拷贝了一份引用，修改拷贝以后的数据会影响原来的数据。<br>浅拷贝只是拷贝一层，更深层次对象级别的值拷贝引用<br>如何浅拷贝：1.直接赋值 2.遍历赋值 3.ES6的语法糖，object.assign(给谁，拷贝谁）只要一层就没有问题</li><li>深拷贝（深度克隆）？<br>特点：拷贝的时候会生成一份新的数据，修改拷贝以后的数据不会原数据。<br>拷贝多层，每一层的数据都会拷贝</li></ul><h5 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h5><p>基本数据类型没有深浅拷贝之说，一定要讲<strong>基本数据类型</strong>就是是<strong>深拷贝</strong></p><pre><code class="js">let a=5;let b=a;b=3;console.log(a,b)</code></pre><h6 id="下面这种newArr会不会改变arr"><a href="#下面这种newArr会不会改变arr" class="headerlink" title="下面这种newArr会不会改变arr?"></a>下面这种newArr会不会改变arr?</h6><pre><code class="js">let arr = [1,2,3];let newArr =[...arr];newArr.push(4);console.log(arr, newArr)</code></pre><p><strong>会！浅拷贝</strong><br>数组与对象的赋值都叫做浅拷贝</p><h6 id="数组与对象的赋值都叫做浅拷贝"><a href="#数组与对象的赋值都叫做浅拷贝" class="headerlink" title="数组与对象的赋值都叫做浅拷贝??"></a>数组与对象的赋值都叫做浅拷贝??</h6><pre><code class="JS">let arr2 = [[1,2,3], [4, 5, 6]];let newArr2 = [...arr2];newArr2[0].push(888);console.log(arr2, newArr2)</code></pre><p><strong>不会！解构赋值深拷贝</strong><br>解构赋值如果针对一维数组和对象，是深拷贝。</p><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><h5 id="props和emit"><a href="#props和emit" class="headerlink" title="props和emit"></a>props和emit</h5><p>子组件通过props选项来声明一个自定义的属性，然后父组件就可以在嵌套标签的时候，通过这个属性往子组件传递数据了。</p><pre><code class="js">&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是父组件！&lt;/h1&gt; &lt;child message=&quot;我是子组件一！&quot;&gt;&lt;/child&gt; //通过自定义属性传递数据 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &#39;../components/child.vue&#39;export default &#123; components: &#123;Child&#125;,&#125;&lt;/script&gt;</code></pre><pre><code class="js">&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&#39;message&#39;] //声明一个自定义的属性 &#125;&lt;/script&gt;</code></pre><h5 id="Ref和parent-children"><a href="#Ref和parent-children" class="headerlink" title="Ref和parent&#x2F;children"></a>Ref和parent&#x2F;children</h5><ul><li><p>如果ref用在子组件上，指向的是组件实例，可以理解为对子组件的索引，通过$ref可能获取到在子组件里定义的属性和方法。</p></li><li><p>如果ref在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过$ref可能获取到该DOM 的属性集合，轻松访问到DOM元素，作用与JQ选择器类似。</p></li></ul><pre><code class="js">&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是父组件！&lt;/h1&gt; &lt;child ref=&quot;msg&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from &#39;../components/child.vue&#39; export default &#123; components: &#123;Child&#125;, mounted: function () &#123;  console.log( this.$refs.msg);  this.$refs.msg.getMessage(&#39;我是子组件一！&#39;) &#125; &#125;&lt;/script&gt;</code></pre><pre><code class="js">&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123;  return&#123;  message:&#39;&#39;  &#125; &#125;, methods:&#123;  getMessage(m)&#123;  this.message=m;  &#125; &#125; &#125;&lt;/script&gt;</code></pre><p>从上面的代码我们可以发现，通过ref&#x3D;‘msg’可以将子组件child的实例指给ref，并且通过.msg.getMessage（）调用到子组件的getMessage方法，将参数传递给子组件。<br>prop和ref之间的区别：<br>prop 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。<br>$ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。</p><h5 id="eventBus-兄弟、父子组件通信"><a href="#eventBus-兄弟、父子组件通信" class="headerlink" title="eventBus 兄弟、父子组件通信"></a>eventBus 兄弟、父子组件通信</h5><h5 id="attrs-listeners-隔代通信"><a href="#attrs-listeners-隔代通信" class="headerlink" title="$attrs\listeners 隔代通信"></a>$attrs\listeners 隔代通信</h5><p>$attrs的使用 vue<br>$attrs是在vue的2.40版本以上添加的。<br>项目中有多层组件传参可以使用$attrs，可以使代码更加美观，更加简洁，维护代码的时候更方便。如果使用普通的父子组件传参prop和$emit，$on会很繁琐；如果使用vuex会大材小用，只是在这几个组件中使用，没必要使用vuex；使用事件总线eventBus，使用不恰当的话，有可能会出现事件多次执行。<br>如果给组件传递的数据，组件不使用props接收，那么这些数据将作为组件的HTML元素的特性，这些特性绑定在组件的HTML根元素上<br>inheritAttrs: false的含义是不希望本组件的根元素继承父组件的attribute，同时父组件传过来的属性（没有被子组件的props接收的属性），也不会显示在子组件的dom元素上，但是在组件里可以通过其$attrs可以获取到没有使用的注册属性, <code>inheritAttrs: false</code>是不会影响 style 和 class 的绑定<br>1）父组件的代码:给子组件关联数据，子组件如果不用props接收，那么这些数据就作为普通的HTML特性应用在子组件的根元素上</p><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;el-table :data=&#39;list&#39;&gt;      &lt;el-table-column        prop=&quot;name&quot;        label=&quot;姓名&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column        prop=&quot;study&quot;        label=&quot;学习科目&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;操作&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-button @click=&#39;transmitClick(scope.row)&#39;&gt;传递&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;        &lt;!-- 儿子组件 --&gt;    &lt;ChildView      :is-show=&quot;isOpen&quot;      :row=&quot;row&quot;    &gt;    &lt;/ChildView&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildView from &#39;./Child.vue&#39;export default &#123;  components: &#123; ChildView &#125;,  data() &#123;    return &#123;      isOpen: false,      row: &#123;&#125;,      list: [        &#123; name: &#39;王丽&#39;, study: &#39;Java&#39; &#125;,        &#123; name: &#39;李克&#39;, study: &#39;Python&#39; &#125;      ]    &#125;  &#125;,  methods: &#123;    // 传递事件    transmitClick(row) &#123;      this.isOpen = true;      this.row = row    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>2)儿子组件，中间层，作为父组件和孙子组件的传递中介，在儿子组件中给孙子组件添加v-bind&#x3D;”$attrs”，这样孙子组件才能接收到数据</p><pre><code class="js">&lt;template&gt;  &lt;div class=&#39;child-view&#39;&gt;    &lt;p&gt;儿子组件&lt;/p&gt;    &lt;GrandChild v-bind=&quot;$attrs&quot;&gt;&lt;/GrandChild&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandChild from &#39;./GrandChild.vue&#39;export default &#123;  // 继承所有父组件的内容  inheritAttrs: true,  components: &#123; GrandChild &#125;,  data() &#123;    return &#123;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt;.child-view &#123;  margin: 20px  border: 2px solid red  padding: 20px&#125;&lt;/style&gt;</code></pre><p>3)孙子组件：在孙子组件中一定要使用props接收从父组件传递过来的数据</p><pre><code class="js">&lt;template&gt;  &lt;div class=&#39;grand-child-view&#39;&gt;    &lt;p&gt;孙子组件&lt;/p&gt;    &lt;p&gt;传给孙子组件的数据：&#123;&#123;row.name&#125;&#125; &#123;&#123;row.name !== undefined? '学习' : ''&#125;&#125; &#123;&#123;row.study&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  // 不想继承所有父组件的内容,同时也不在组件根元素dom上显示属性  inheritAttrs: false,  // 在本组件中需要接收从父组件传递过来的数据，注意props里的参数名称不能改变，必须和父组件传递过来的是一样的  props: &#123;    isShow: &#123;      type: Boolean,      dedault: false    &#125;,    row: &#123;      type: Object,      dedault: () =&gt; &#123; &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt;.grand-child-view &#123;  border: 2px solid green  padding: 20px  margin: 20px&#125;&lt;/style&gt;</code></pre><p>5、Provide\inject 隔代组件通信<br>6、Vuex<br>7、Pubsub库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嗨~这里是在网上找到的一些资料或者b站视频后整理的一些知识点，接下来会不断更新…&lt;br&gt;…&lt;/p&gt;
&lt;h3 id=&quot;css高频&quot;&gt;&lt;a href=&quot;#css高频&quot; class=&quot;headerlink&quot; title=&quot;css高频&quot;&gt;&lt;/a&gt;css高频&lt;/h3&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="html" scheme="http://example.com/tags/html/"/>
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Alice&#39;s First Blog</title>
    <link href="http://example.com/2023/10/26/firstBlog/"/>
    <id>http://example.com/2023/10/26/firstBlog/</id>
    <published>2023-10-26T14:20:39.271Z</published>
    <updated>2023-11-01T02:56:13.596Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎你来到我的博客网站！这是我的一方小天地呀~</p><p>这里将会记录我的学习和知识…</p><h3 id="搭建bolg资料和网站"><a href="#搭建bolg资料和网站" class="headerlink" title="搭建bolg资料和网站"></a>搭建bolg资料和网站</h3><p>在线md： <a href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a><br>Butterfly 主题的详细配置：<br><a href="https://liangshenglei.github.io/2023/03/06/Butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/index.html">https://liangshenglei.github.io/2023/03/06/Butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/index.html</a><br>背景：<br>1.Hexo-Butterfly主题优化-设置网站首页显示背景、文章最上方不显示背景 <a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a><br>2. Butterfly主题优化首页大图加载效果 <a href="http://demian.wang/2021/06/05/Butterfly%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/">http://demian.wang/2021/06/05/Butterfly%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/</a></p><p>分类以及标签页<br>1.Hexo使用攻略-添加分类及标签<a href="https://www.jianshu.com/p/e17711e44e00">https://www.jianshu.com/p/e17711e44e00</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎你来到我的博客网站！这是我的一方小天地呀~&lt;/p&gt;
&lt;p&gt;这里将会记录我的学习和知识…&lt;/p&gt;
&lt;h3 id=&quot;搭建bolg资料和网站&quot;&gt;&lt;a href=&quot;#搭建bolg资料和网站&quot; class=&quot;headerlink&quot; title=&quot;搭建bolg资料和网站&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo的基础配置</title>
    <link href="http://example.com/2023/10/26/hello-world/"/>
    <id>http://example.com/2023/10/26/hello-world/</id>
    <published>2023-10-26T11:42:54.873Z</published>
    <updated>2023-10-30T08:49:37.437Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
