<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AliceBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-29T13:39:25.335Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Alice</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springMVC学习</title>
    <link href="http://example.com/2023/11/29/springMVC/"/>
    <id>http://example.com/2023/11/29/springMVC/</id>
    <published>2023-11-29T13:38:48.615Z</published>
    <updated>2023-11-29T13:39:25.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC 是目前主流的实现 MVC 设计模式的企业级开发框架，Spring 框架的一个子模块，无需整合，开发起来更加便捷。</p><h4 id="什么是-MVC-设计模式？"><a href="#什么是-MVC-设计模式？" class="headerlink" title="什么是 MVC 设计模式？"></a>什么是 MVC 设计模式？</h4><p>将应用程序分为 Controller、Model、View 三层，Controller 接收客户端请求，调用 Model 生成业务数据，传递给 View。</p><p>Spring MVC 就是对这套流程的封装，屏蔽了很多底层代码，开放出接口，让开发者可以更加轻松、便捷地完成基于 MVC 模式的 Web 开发。</p><h4 id="Spring-MVC-的核心组件"><a href="#Spring-MVC-的核心组件" class="headerlink" title="Spring MVC 的核心组件"></a>Spring MVC 的核心组件</h4><ul><li>DispatcherServlet：前置控制器，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li><li>Handler：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li><li>HandlerMapping：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li><li>HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li><li>HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li><li>HandlerAdapter：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li><li>ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li><li>ViewResolver：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li></ul><h4 id="Spring-MVC-的工作流程"><a href="#Spring-MVC-的工作流程" class="headerlink" title="Spring MVC 的工作流程"></a>Spring MVC 的工作流程</h4><ul><li>客户端请求被 DisptacherServlet 接收。</li><li>根据 HandlerMapping 映射到 Handler。</li><li>生成 Handler 和 HandlerInterceptor。</li><li>Handler 和 HandlerInterceptor 以 HandlerExecutionChain 的形式一并返回给 DisptacherServlet。</li><li>DispatcherServlet 通过 HandlerAdapter 调用 Handler 的方法完成业务逻辑处理。</li><li>Handler 返回一个 ModelAndView 给 DispatcherServlet。</li><li>DispatcherServlet 将获取的 ModelAndView 对象传给 ViewResolver 视图解析器，将逻辑视图解析为物理视图 View。</li><li>ViewResovler 返回一个 View 给 DispatcherServlet。</li><li>DispatcherServlet 根据 View 进行视图渲染（将模型数据 Model 填充到视图 View 中）。</li><li>DispatcherServlet 将渲染后的结果响应给客户端。</li></ul><p>![image-20190313111136254](&#x2F;Users&#x2F;southwind&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20190313111136254.png)</p><p>Spring MVC 流程非常复杂，实际开发中很简单，因为大部分的组件不需要开发者创建、管理，只需要通过配置文件的方式完成配置即可，真正需要开发者进行处理的只有 Handler 、View。</p><h4 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h4><ul><li>创建 Maven 工程，pom.xml</li></ul><pre><code class="xml">&lt;dependencies&gt;     &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;    &lt;/dependency&gt; &lt;/dependencies&gt;</code></pre><ul><li>在 web.xml 中配置 DispatcherServlet。</li></ul><pre><code class="xml">&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt; &lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;     &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;     &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;   &lt;/web-app&gt;</code></pre><ul><li>springmvc.xml</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&gt;     &lt;!-- 自动扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.southwind&quot;&gt;&lt;/context:component-scan&gt;     &lt;!-- 配置视图解析器 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt; &lt;/beans&gt;</code></pre><ul><li>创建 Handler</li></ul><pre><code class="java">package com.southwind.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping; @Controllerpublic class HelloHandler &#123;     @RequestMapping(&quot;/index&quot;)    public String index()&#123;        System.out.println(&quot;执行了index...&quot;);        return &quot;index&quot;;    &#125;&#125;</code></pre><h3 id="Spring-MVC-注解"><a href="#Spring-MVC-注解" class="headerlink" title="Spring MVC 注解"></a>Spring MVC 注解</h3><ul><li>@RequestMapping</li></ul><p>Spring MVC 通过 @RequestMapping 注解将 URL 请求与业务方法进行映射，在 Handler 的类定义处以及方法定义处都可以添加 @RequestMapping ，在类定义处添加，相当于客户端多了一层访问路径。</p><ul><li>@Controller</li></ul><p>@Controller 在类定义处添加，将该类交个 IoC 容器来管理（结合 springmvc.xml 的自动扫描配置使用），同时使其成为一个控制器，可以接收客户端请求。</p><pre><code class="java">package com.southwind.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(&quot;/hello&quot;)public class HelloHandler &#123;     @RequestMapping(&quot;/index&quot;)    public String index()&#123;        System.out.println(&quot;执行了index...&quot;);        return &quot;index&quot;;    &#125;&#125;</code></pre><ul><li>@RequestMapping 相关参数</li></ul><p>1、value：指定 URL 请求的实际地址，是 @RequestMapping 的默认值。</p><pre><code class="java">@RequestMapping(&quot;/index&quot;)public String index()&#123;    System.out.println(&quot;执行了index...&quot;);    return &quot;index&quot;;&#125;</code></pre><p>等于</p><pre><code class="java">@RequestMapping(value=&quot;/index&quot;)public String index()&#123;    System.out.println(&quot;执行了index...&quot;);    return &quot;index&quot;;&#125;</code></pre><p>2、method：指定请求的 method 类型，GET、POST、PUT、DELET。</p><pre><code class="java">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET)public String index()&#123;    System.out.println(&quot;执行了index...&quot;);    return &quot;index&quot;;&#125;</code></pre><p>上述代码表示 index 方法只能接收 GET 请求。</p><p>3、params：指定请求中必须包含某些参数，否则无法调用该方法。</p><pre><code class="java">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET,params = &#123;&quot;name&quot;,&quot;id=10&quot;&#125;)public String index()&#123;    System.out.println(&quot;执行了index...&quot;);    return &quot;index&quot;;&#125;</code></pre><p>上述代码表示请求中必须包含 name 和 id 两个参数，同时 id 的值必须是 10。</p><p>关于参数绑定，在形参列表中通过添加 @RequestParam 注解完成 HTTP 请求参数与业务方法形参的映射。</p><pre><code class="java">@RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET,params = &#123;&quot;name&quot;,&quot;id=10&quot;&#125;)public String index(@RequestParam(&quot;name&quot;) String str,@RequestParam(&quot;id&quot;) int age)&#123;    System.out.println(str);    System.out.println(age);    System.out.println(&quot;执行了index...&quot;);    return &quot;index&quot;;&#125;</code></pre><p>上述代码表示将请求的参数 name 和 id 分别赋给了形参 str 和 age ，同时自动完成了数据类型转换，将 “10” 转为了 int 类型的 10，再赋给 age，这些工作都是由 HandlerAdapter 来完成的。</p><p>Spring MVC 也支持 RESTful 风格的 URL。</p><p>传统类型：<a href="http://localhost:8080/hello/index?name=zhangsan&id=10">http://localhost:8080/hello/index?name=zhangsan&amp;id=10</a></p><p>REST：<a href="http://localhost:8080/hello/index/zhangsan/10">http://localhost:8080/hello/index/zhangsan/10</a></p><pre><code class="java">@RequestMapping(&quot;/rest/&#123;name&#125;/&#123;id&#125;&quot;)public String rest(@PathVariable(&quot;name&quot;) String name,@PathVariable(&quot;id&quot;) int id)&#123;    System.out.println(name);    System.out.println(id);    return &quot;index&quot;;&#125;</code></pre><p>通过 @PathVariable 注解完成请求参数与形参的映射。</p><ul><li>映射 Cookie</li></ul><p>Spring MVC 通过映射可以直接在业务方法中获取 Cookie 的值。</p><pre><code class="java">@RequestMapping(&quot;/cookie&quot;)public String cookie(@CookieValue(value = &quot;JSESSIONID&quot;) String sessionId)&#123;    System.out.println(sessionId);    return &quot;index&quot;;&#125;</code></pre><ul><li>使用 JavaBean 绑定参数</li></ul><p>Spring MVC 会根据请求参数名和 JavaBean 属性名进行自动匹配，自动为对象填充属性值，同时支持及联属性。</p><pre><code class="java">package com.southwind.entity; import lombok.Data; @Datapublic class Address &#123;    private String value;&#125;</code></pre><pre><code class="java">package com.southwind.entity; import lombok.Data; @Datapublic class User &#123;    private long id;    private String name;    private Address address;&#125;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-13  Time: 15:33  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/hello/save&quot; method=&quot;post&quot;&gt;        用户id：&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br/&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;        用户地址：&lt;input type=&quot;text&quot; name=&quot;address.value&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="java">@RequestMapping(value = &quot;/save&quot;,method = RequestMethod.POST)public String save(User user)&#123;    System.out.println(user);    return &quot;index&quot;;&#125;</code></pre><p>如果出现中文乱码问题，只需在 web.xml 添加 Spring MVC 自带的过滤器即可。</p><pre><code class="xml">&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;/param-name&gt;        &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt; &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre><ul><li>JSP 页面的转发和重定向：</li></ul><p>Spring MVC 默认是以转发的形式响应 JSP。</p><p>1、转发</p><pre><code class="java">@RequestMapping(&quot;/forward&quot;)public String forward()&#123;    return &quot;forward:/index.jsp&quot;;    //        return &quot;index&quot;;&#125;</code></pre><p>2、重定向</p><pre><code class="java">@RequestMapping(&quot;/redirect&quot;)public String redirect()&#123;    return &quot;redirect:/index.jsp&quot;;&#125;</code></pre><h3 id="Spring-MVC-数据绑定"><a href="#Spring-MVC-数据绑定" class="headerlink" title="Spring MVC 数据绑定"></a>Spring MVC 数据绑定</h3><p>数据绑定：在后端的业务方法中直接获取客户端 HTTP 请求中的参数，将请求参数映射到业务方法的形参中，Spring MVC 中数据绑定的工作是由 HandlerAdapter 来完成的。</p><ul><li>基本数据类型</li></ul><pre><code class="java">@RequestMapping(&quot;/baseType&quot;)@ResponseBodypublic String baseType(int id)&#123;    return id+&quot;&quot;;&#125;</code></pre><p>@ResponseBody 表示 Spring MVC 会直接将业务方法的返回值响应给客户端，如果不加 @ResponseBody 注解，Spring MVC 会将业务方法的放回值传递给 DispatcherServlet，再由 DisptacherServlet 调用 ViewResolver 对返回值进行解析，映射到一个 JSP 资源。</p><ul><li>包装类</li></ul><pre><code class="java">@RequestMapping(&quot;/packageType&quot;)@ResponseBodypublic String packageType(@RequestParam(value = &quot;num&quot;,required = false,defaultValue = &quot;0&quot;) Integer id)&#123;    return id+&quot;&quot;;&#125;</code></pre><p>包装类可以接收 null，当 HTTP 请求没有参数时，使用包装类定义形参的数据类型，程序不会抛出异常。</p><p>@RequestParam</p><p>value &#x3D; “num”：将 HTTP 请求中名为 num 的参数赋给形参 id。</p><p>requried：设置 num 是否为必填项，true 表示必填，false 表示非必填，可省略。</p><p>defaultValue &#x3D; “0”：如果 HTTP 请求中没有 num 参数，默认值为0.</p><ul><li>数组</li></ul><pre><code class="java">@RestController@RequestMapping(&quot;/data&quot;)public class DataBindHandler &#123;    @RequestMapping(&quot;/array&quot;)    public String array(String[] name)&#123;        String str = Arrays.toString(name);        return str;    &#125;&#125;</code></pre><p>@RestController 表示该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析。</p><p>@Controller 表示该控制器的每一个业务方法的返回值都会交给视图解析器进行解析，如果只需要将数据响应给客户端，而不需要进行视图解析，则需要在对应的业务方法定义处添加 @ResponseBody。</p><pre><code class="java">@RestController@RequestMapping(&quot;/data&quot;)public class DataBindHandler &#123;    @RequestMapping(&quot;/array&quot;)    public String array(String[] name)&#123;        String str = Arrays.toString(name);        return str;    &#125;&#125;</code></pre><p>等同于</p><pre><code class="java">@Controller@RequestMapping(&quot;/data&quot;)public class DataBindHandler &#123;    @RequestMapping(&quot;/array&quot;)    @ResponseBody    public String array(String[] name)&#123;        String str = Arrays.toString(name);        return str;    &#125;&#125;</code></pre><ul><li>List</li></ul><p>Spring MVC 不支持 List 类型的直接转换，需要对 List 集合进行包装。</p><p>集合封装类</p><pre><code class="java">package com.southwind.entity; import lombok.Data; import java.util.List; @Datapublic class UserList &#123;    private List&lt;User&gt; users;&#125;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 09:12  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/data/list&quot; method=&quot;post&quot;&gt;        用户1编号：&lt;input type=&quot;text&quot; name=&quot;users[0].id&quot;/&gt;&lt;br/&gt;        用户1名称：&lt;input type=&quot;text&quot; name=&quot;users[0].name&quot;/&gt;&lt;br/&gt;        用户2编号：&lt;input type=&quot;text&quot; name=&quot;users[1].id&quot;/&gt;&lt;br/&gt;        用户2名称：&lt;input type=&quot;text&quot; name=&quot;users[1].name&quot;/&gt;&lt;br/&gt;        用户3编号：&lt;input type=&quot;text&quot; name=&quot;users[2].id&quot;/&gt;&lt;br/&gt;        用户3名称：&lt;input type=&quot;text&quot; name=&quot;users[2].name&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>业务方法</p><pre><code class="java">@RequestMapping(&quot;/list&quot;)public String list(UserList userList)&#123;    StringBuffer str = new StringBuffer();    for(User user:userList.getUsers())&#123;        str.append(user);    &#125;    return str.toString();&#125;</code></pre><p>处理 @ResponseBody 中文乱码，在 springmvc.xml 中配置消息转换器。</p><pre><code class="xml">&lt;mvc:annotation-driven&gt;    &lt;!-- 消息转换器 --&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><ul><li>Map</li></ul><p>自定义封装类</p><pre><code class="java">package com.southwind.entity; import lombok.Data; import java.util.Map; @Datapublic class UserMap &#123;    private Map&lt;String,User&gt; users;&#125;</code></pre><p>业务方法</p><pre><code class="java">@RequestMapping(&quot;/map&quot;)public String map(UserMap userMap)&#123;    StringBuffer str = new StringBuffer();    for(String key:userMap.getUsers().keySet())&#123;        User user = userMap.getUsers().get(key);        str.append(user);    &#125;    return str.toString();&#125;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 09:12  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/data/map&quot; method=&quot;post&quot;&gt;        用户1编号：&lt;input type=&quot;text&quot; name=&quot;users[&#39;a&#39;].id&quot;/&gt;&lt;br/&gt;        用户1名称：&lt;input type=&quot;text&quot; name=&quot;users[&#39;a&#39;].name&quot;/&gt;&lt;br/&gt;        用户2编号：&lt;input type=&quot;text&quot; name=&quot;users[&#39;b&#39;].id&quot;/&gt;&lt;br/&gt;        用户2名称：&lt;input type=&quot;text&quot; name=&quot;users[&#39;b&#39;].name&quot;/&gt;&lt;br/&gt;        用户3编号：&lt;input type=&quot;text&quot; name=&quot;users[&#39;c&#39;].id&quot;/&gt;&lt;br/&gt;        用户3名称：&lt;input type=&quot;text&quot; name=&quot;users[&#39;c&#39;].name&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>JSON</li></ul><p>客户端发生 JSON 格式的数据，直接通过 Spring MVC 绑定到业务方法的形参中。</p><p>处理 Spring MVC 无法加载静态资源，在 web.xml 中添加配置即可。</p><pre><code class="xml">&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 10:35  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(function()&#123;           var user = &#123;               &quot;id&quot;:1,               &quot;name&quot;:&quot;张三&quot;           &#125;;           $.ajax(&#123;               url:&quot;/data/json&quot;,               data:JSON.stringify(user),               type:&quot;POST&quot;,               contentType:&quot;application/json;charset=UTF-8&quot;,               dataType:&quot;JSON&quot;,               success:function(data)&#123;                   alter(data.id+&quot;---&quot;+data.name);               &#125;           &#125;)        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;</code></pre><p>业务方法</p><pre><code class="java">@RequestMapping(&quot;/json&quot;)public User json(@RequestBody User user)&#123;    System.out.println(user);    user.setId(6);    user.setName(&quot;张六&quot;);    return user;&#125;</code></pre><p>Spring MVC 中的 JSON 和 JavaBean 的转换需要借助于 fastjson，pom.xml 引入相关依赖。</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.32&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>springmvc.xml 添加 fastjson 配置。</p><pre><code class="xml">&lt;mvc:annotation-driven&gt;    &lt;!-- 消息转换器 --&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;        &lt;!-- 配置fastjson --&gt;        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;&gt;&lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><h3 id="Spring-MVC-模型数据解析"><a href="#Spring-MVC-模型数据解析" class="headerlink" title="Spring MVC 模型数据解析"></a>Spring MVC 模型数据解析</h3><p>JSP 四大作用域对应的内置对象：pageContext、request、session、application。</p><p>模型数据的绑定是由 ViewResolver 来完成的，实际开发中，我们需要先添加模型数据，再交给 ViewResolver 来绑定。</p><p>Spring MVC 提供了以下几种方式添加模型数据：</p><ul><li>Map</li><li>Model</li><li>ModelAndView</li><li>@SessionAttribute</li><li>@ModelAttribute</li></ul><blockquote><p>将模式数据绑定到 request 对象。</p></blockquote><p>1、Map</p><pre><code class="java">@RequestMapping(&quot;/map&quot;)public String map(Map&lt;String,User&gt; map)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    map.put(&quot;user&quot;,user);    return &quot;view&quot;;&#125;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 11:36  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    $&#123;requestScope.user&#125;&lt;/body&gt;&lt;/html&gt;</code></pre><p>2、Model</p><pre><code class="java">@RequestMapping(&quot;/model&quot;)public String model(Model model)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    model.addAttribute(&quot;user&quot;,user);    return &quot;view&quot;;&#125;</code></pre><p>3、ModelAndView</p><pre><code class="java">@RequestMapping(&quot;/modelAndView&quot;)public ModelAndView modelAndView()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    ModelAndView modelAndView = new ModelAndView();    modelAndView.addObject(&quot;user&quot;,user);    modelAndView.setViewName(&quot;view&quot;);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView2&quot;)public ModelAndView modelAndView2()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    ModelAndView modelAndView = new ModelAndView();    modelAndView.addObject(&quot;user&quot;,user);    View view = new InternalResourceView(&quot;/view.jsp&quot;);    modelAndView.setView(view);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView3&quot;)public ModelAndView modelAndView3()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    ModelAndView modelAndView = new ModelAndView(&quot;view&quot;);    modelAndView.addObject(&quot;user&quot;,user);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView4&quot;)public ModelAndView modelAndView4()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    View view = new InternalResourceView(&quot;/view.jsp&quot;);    ModelAndView modelAndView = new ModelAndView(view);    modelAndView.addObject(&quot;user&quot;,user);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView5&quot;)public ModelAndView modelAndView5()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    Map&lt;String,User&gt; map = new HashMap&lt;&gt;();    map.put(&quot;user&quot;,user);    ModelAndView modelAndView = new ModelAndView(&quot;view&quot;,map);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView6&quot;)public ModelAndView modelAndView6()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    Map&lt;String,User&gt; map = new HashMap&lt;&gt;();    map.put(&quot;user&quot;,user);    View view = new InternalResourceView(&quot;/view.jsp&quot;);    ModelAndView modelAndView = new ModelAndView(view,map);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView7&quot;)public ModelAndView modelAndView7()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    ModelAndView modelAndView = new ModelAndView(&quot;view&quot;,&quot;user&quot;,user);    return modelAndView;&#125; @RequestMapping(&quot;/modelAndView8&quot;)public ModelAndView modelAndView8()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    View view = new InternalResourceView(&quot;/view.jsp&quot;);    ModelAndView modelAndView = new ModelAndView(view,&quot;user&quot;,user);    return modelAndView;&#125;</code></pre><p>4、HttpServletRequest</p><pre><code class="java">@RequestMapping(&quot;/request&quot;)public String request(HttpServletRequest request)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    request.setAttribute(&quot;user&quot;,user);    return &quot;view&quot;;&#125;</code></pre><p>5、@ModelAttribute</p><ul><li>定义一个方法，该方法专门用来返回要填充到模型数据中的对象。</li></ul><pre><code class="java">@ModelAttributepublic User getUser()&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    return user;&#125;</code></pre><pre><code class="java">@ModelAttributepublic void getUser(Map&lt;String,User&gt; map)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    map.put(&quot;user&quot;,user);&#125;</code></pre><pre><code class="java">@ModelAttributepublic void getUser(Model model)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    model.addAttribute(&quot;user&quot;,user);&#125;</code></pre><ul><li>业务方法中无需再处理模型数据，只需返回视图即可。</li></ul><pre><code class="java">@RequestMapping(&quot;/modelAttribute&quot;)public String modelAttribute()&#123;    return &quot;view&quot;;&#125;</code></pre><blockquote><p>将模型数据绑定到 session 对象</p></blockquote><p>1、直接使用原生的 Servlet API。</p><pre><code class="java">@RequestMapping(&quot;/session&quot;)public String session(HttpServletRequest request)&#123;    HttpSession session = request.getSession();    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    session.setAttribute(&quot;user&quot;,user);    return &quot;view&quot;;&#125; @RequestMapping(&quot;/session2&quot;)public String session2(HttpSession session)&#123;    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    session.setAttribute(&quot;user&quot;,user);    return &quot;view&quot;;&#125;</code></pre><p>2、@SessionAttribute</p><pre><code class="java">@SessionAttributes(value = &#123;&quot;user&quot;,&quot;address&quot;&#125;)public class ViewHandler &#123;&#125;</code></pre><p>对于 ViewHandler 中的所有业务方法，只要向 request 中添加了 key &#x3D; “user”、key &#x3D; “address” 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。</p><pre><code class="java">@SessionAttributes(types = &#123;User.class,Address.class&#125;)public class ViewHandler &#123;&#125;</code></pre><p>对于 ViewHandler 中的所有业务方法，只要向 request 中添加了数据类型是 User 、Address 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变。</p><blockquote><p>将模型数据绑定到 application 对象</p></blockquote><pre><code class="java">@RequestMapping(&quot;/application&quot;)public String application(HttpServletRequest request)&#123;    ServletContext application = request.getServletContext();    User user = new User();    user.setId(1L);    user.setName(&quot;张三&quot;);    application.setAttribute(&quot;user&quot;,user);    return &quot;view&quot;;&#125;</code></pre><h3 id="Spring-MVC-自定义数据转换器"><a href="#Spring-MVC-自定义数据转换器" class="headerlink" title="Spring MVC 自定义数据转换器"></a>Spring MVC 自定义数据转换器</h3><p>数据转换器是指将客户端 HTTP 请求中的参数转换为业务方法中定义的形参，自定义表示开发者可以自主设计转换的方式，HandlerApdter 已经提供了通用的转换，String 转 int，String 转 double，表单数据的封装等，但是在特殊的业务场景下，HandlerAdapter 无法进行转换，就需要开发者自定义转换器。</p><p>客户端输入 String 类型的数据 “2019-03-03”，自定义转换器将该数据转为 Date 类型的对象。</p><ul><li>创建 DateConverter 转换器，实现 Conveter 接口。</li></ul><pre><code class="java">package com.southwind.converter; import org.springframework.core.convert.converter.Converter; import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date; public class DateConverter implements Converter&lt;String, Date&gt; &#123;     private String pattern;     public DateConverter(String pattern)&#123;        this.pattern = pattern;    &#125;     @Override    public Date convert(String s) &#123;        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(this.pattern);        Date date = null;        try &#123;            date = simpleDateFormat.parse(s);        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;        return date;    &#125;&#125;</code></pre><ul><li>springmvc.xml 配置转换器。</li></ul><pre><code class="xml">&lt;!-- 配置自定义转换器 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;com.southwind.converter.DateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;&gt;&lt;/constructor-arg&gt;            &lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;    &lt;!-- 消息转换器 --&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;        &lt;!-- 配置fastjson --&gt;        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;&gt;&lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 14:47  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/converter/date&quot; method=&quot;post&quot;&gt;        请输入日期:&lt;input type=&quot;text&quot; name=&quot;date&quot;/&gt;(yyyy-MM-dd)&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>Handler</li></ul><pre><code class="java">package com.southwind.controller; import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; import java.util.Date; @RestController@RequestMapping(&quot;/converter&quot;)public class ConverterHandler &#123;     @RequestMapping(&quot;/date&quot;)    public String date(Date date)&#123;        return date.toString();    &#125;&#125;</code></pre><p>String 转 Student</p><p>StudentConverter</p><pre><code class="java">package com.southwind.converter; import com.southwind.entity.Student;import org.springframework.core.convert.converter.Converter; public class StudentConverter implements Converter&lt;String, Student&gt; &#123;    @Override    public Student convert(String s) &#123;        String[] args = s.split(&quot;-&quot;);        Student student = new Student();        student.setId(Long.parseLong(args[0]));        student.setName(args[1]);        student.setAge(Integer.parseInt(args[2]));        return student;    &#125;&#125;</code></pre><p>springmvc.xml</p><pre><code class="xml">&lt;!-- 配置自定义转换器 --&gt;&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;    &lt;property name=&quot;converters&quot;&gt;        &lt;list&gt;            &lt;bean class=&quot;com.southwind.converter.DateConverter&quot;&gt;                &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;yyyy-MM-dd&quot;&gt;&lt;/constructor-arg&gt;            &lt;/bean&gt;            &lt;bean class=&quot;com.southwind.converter.StudentConverter&quot;&gt;&lt;/bean&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;    &lt;!-- 消息转换器 --&gt;    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;property name=&quot;supportedMediaTypes&quot; value=&quot;text/html;charset=UTF-8&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;        &lt;!-- 配置fastjson --&gt;        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4&quot;&gt;&lt;/bean&gt;    &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-14  Time: 15:23  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/converter/student&quot; method=&quot;post&quot;&gt;        请输入学生信息：&lt;input type=&quot;text&quot; name=&quot;student&quot;/&gt;(id-name-age)&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Handler</p><pre><code class="java">@RequestMapping(&quot;/student&quot;)public String student(Student student)&#123;    return student.toString();&#125;</code></pre><h3 id="Spring-MVC-REST"><a href="#Spring-MVC-REST" class="headerlink" title="Spring MVC REST"></a>Spring MVC REST</h3><p>REST：Representational State Transfer，资源表现层状态转换，是目前比较主流的一种互联网软件架构，它结构清晰、标准规范、易于理解、便于扩展。</p><ul><li>资源（Resource）</li></ul><p>网络上的一个实体，或者说网络中存在的一个具体信息，一段文本、一张图片、一首歌曲、一段视频等等，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每个资源都有对应的一个特定的 URI，要获取该资源时，只需要访问对应的 URI 即可。</p><ul><li>表现层（Representation）</li></ul><p>资源具体呈现出来的形式，比如文本可以用 txt 格式表示，也可以用 HTML、XML、JSON等格式来表示。</p><ul><li>状态转换（State Transfer）</li></ul><p>客户端如果希望操作服务器中的某个资源，就需要通过某种方式让服务端发生状态转换，而这种转换是建立在表现层之上的，所有叫做”表现层状态转换”。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>URL 更加简洁。</li><li>有利于不同系统之间的资源共享，只需要遵守一定的规范，不需要进行其他配置即可实现资源共享。</li></ul><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>REST 具体操作就是 HTTP 协议中四个表示操作方式的动词分别对应 CRUD 基本操作。</p><p>GET 用来表示获取资源。</p><p>POST 用来表示新建资源。</p><p>PUT 用来表示修改资源。</p><p>DELETE 用来表示删除资源。</p><p>Handler</p><pre><code class="java">package com.southwind.controller; import com.southwind.entity.Student;import com.southwind.entity.User;import com.southwind.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import org.springframework.web.bind.annotation.*; import javax.servlet.http.HttpServletResponse;import java.util.Collection; @RestController@RequestMapping(&quot;/rest&quot;)public class RESTHandeler &#123;     @Autowired    private StudentRepository studentRepository;     @GetMapping(&quot;/findAll&quot;)    public Collection&lt;Student&gt; findAll(HttpServletResponse response)&#123;        response.setContentType(&quot;text/json;charset=UTF-8&quot;);        return studentRepository.findAll();    &#125;     @GetMapping(&quot;/findById/&#123;id&#125;&quot;)    public Student findById(@PathVariable(&quot;id&quot;) long id)&#123;        return studentRepository.findById(id);    &#125;     @PostMapping(&quot;/save&quot;)    public void save(@RequestBody Student student)&#123;        studentRepository.saveOrUpdate(student);    &#125;     @PutMapping(&quot;/update&quot;)    public void update(@RequestBody Student student)&#123;        studentRepository.saveOrUpdate(student);    &#125;     @DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)    public void deleteById(@PathVariable(&quot;id&quot;) long id)&#123;        studentRepository.deleteById(id);    &#125; &#125;</code></pre><p>StudentRepository</p><pre><code class="java">package com.southwind.repository; import com.southwind.entity.Student; import java.util.Collection; public interface StudentRepository &#123;    public Collection&lt;Student&gt; findAll();    public Student findById(long id);    public void saveOrUpdate(Student student);    public void deleteById(long id);&#125;</code></pre><p>StudentRepositoryImpl</p><pre><code class="java">package com.southwind.repository.impl; import com.southwind.entity.Student;import com.southwind.repository.StudentRepository;import org.springframework.stereotype.Repository; import java.util.Collection;import java.util.HashMap;import java.util.Map; @Repositorypublic class StudentRepositoryImpl implements StudentRepository &#123;     private static Map&lt;Long,Student&gt; studentMap;     static&#123;        studentMap = new HashMap&lt;&gt;();        studentMap.put(1L,new Student(1L,&quot;张三&quot;,22));        studentMap.put(2L,new Student(2L,&quot;李四&quot;,23));        studentMap.put(3L,new Student(3L,&quot;王五&quot;,24));    &#125;     @Override    public Collection&lt;Student&gt; findAll() &#123;        return studentMap.values();    &#125;     @Override    public Student findById(long id) &#123;        return studentMap.get(id);    &#125;     @Override    public void saveOrUpdate(Student student) &#123;        studentMap.put(student.getId(),student);    &#125;     @Override    public void deleteById(long id) &#123;        studentMap.remove(id);    &#125;&#125;</code></pre><h3 id="Spring-MVC-文件上传下载"><a href="#Spring-MVC-文件上传下载" class="headerlink" title="Spring MVC 文件上传下载"></a>Spring MVC 文件上传下载</h3><blockquote><p>单文件上传</p></blockquote><p>底层是使用 Apache fileupload 组件完成上传，Spring MVC 对这种方式进行了封装。</p><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-15  Time: 09:09  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/file/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;img&quot;/&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;    &lt;img src=&quot;$&#123;path&#125;&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>1、input 的 type 设置为 file。</p><p>2、form 的 method 设置为 post（get 请求只能将文件名传给服务器）</p><p>3、from 的 enctype 设置为 multipart-form-data（如果不设置只能将文件名传给服务器）</p><ul><li>Handler</li></ul><pre><code class="java">package com.southwind.controller; import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException; @Controller@RequestMapping(&quot;/file&quot;)public class FileHandler &#123;     @PostMapping(&quot;/upload&quot;)    public String upload(MultipartFile img, HttpServletRequest request)&#123;        if(img.getSize()&gt;0)&#123;            //获取保存上传文件的file路径            String path = request.getServletContext().getRealPath(&quot;file&quot;);            //获取上传的文件名            String name = img.getOriginalFilename();            File file = new File(path,name);            try &#123;                img.transferTo(file);                //保存上传之后的文件路径                request.setAttribute(&quot;path&quot;,&quot;/file/&quot;+name);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        return &quot;upload&quot;;    &#125;&#125;</code></pre><ul><li>springmvc.xml</li></ul><pre><code class="xml">&lt;!-- 配置上传组件 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt;</code></pre><ul><li>web.xml 添加如下配置，否则客户端无法访问 png</li></ul><pre><code class="xml">&lt;servlet-mapping&gt;    &lt;servlet-name&gt;default&lt;/servlet-name&gt;    &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><blockquote><p>多文件上传</p></blockquote><p>pom.xml</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;jstl&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>JSP</p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-15  Time: 09:32  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;/file/uploads&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        file1:&lt;input type=&quot;file&quot; name=&quot;imgs&quot;/&gt;&lt;br/&gt;        file2:&lt;input type=&quot;file&quot; name=&quot;imgs&quot;/&gt;&lt;br/&gt;        file3:&lt;input type=&quot;file&quot; name=&quot;imgs&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;    &lt;/form&gt;    &lt;c:forEach items=&quot;$&#123;files&#125;&quot; var=&quot;file&quot; &gt;        &lt;img src=&quot;$&#123;file&#125;&quot; width=&quot;300px&quot;&gt;    &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>Handler</p><pre><code class="java">@PostMapping(&quot;/uploads&quot;)public String uploads(MultipartFile[] imgs,HttpServletRequest request)&#123;    List&lt;String&gt; files = new ArrayList&lt;&gt;();    for (MultipartFile img:imgs)&#123;        if(img.getSize()&gt;0)&#123;            //获取保存上传文件的file路径            String path = request.getServletContext().getRealPath(&quot;file&quot;);            //获取上传的文件名            String name = img.getOriginalFilename();            File file = new File(path,name);            try &#123;                img.transferTo(file);                //保存上传之后的文件路径                files.add(&quot;/file/&quot;+name);            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    request.setAttribute(&quot;files&quot;,files);    return &quot;uploads&quot;;&#125;</code></pre><blockquote><p>下载</p></blockquote><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-15  Time: 10:36  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;/file/download/1&quot;&gt;1.png&lt;/a&gt;    &lt;a href=&quot;/file/download/2&quot;&gt;2.png&lt;/a&gt;    &lt;a href=&quot;/file/download/3&quot;&gt;3.png&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>Handler</li></ul><pre><code class="java">@GetMapping(&quot;/download/&#123;name&#125;&quot;)public void download(@PathVariable(&quot;name&quot;) String name, HttpServletRequest request, HttpServletResponse response)&#123;    if(name != null)&#123;        name += &quot;.png&quot;;        String path = request.getServletContext().getRealPath(&quot;file&quot;);        File file = new File(path,name);        OutputStream outputStream = null;        if(file.exists())&#123;            response.setContentType(&quot;application/forc-download&quot;);            response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+name);            try &#123;                outputStream = response.getOutputStream();                outputStream.write(FileUtils.readFileToByteArray(file));                outputStream.flush();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125; finally &#123;                if(outputStream != null)&#123;                    try &#123;                        outputStream.close();                    &#125; catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="Spring-MVC-表单标签库"><a href="#Spring-MVC-表单标签库" class="headerlink" title="Spring MVC 表单标签库"></a>Spring MVC 表单标签库</h3><ul><li>Handler</li></ul><pre><code class="java">@GetMapping(&quot;/get&quot;)public ModelAndView get()&#123;    ModelAndView modelAndView = new ModelAndView(&quot;tag&quot;);    Student student = new Student(1L,&quot;张三&quot;,22);    modelAndView.addObject(&quot;student&quot;,student);    return modelAndView;&#125;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-15  Time: 10:53  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;学生信息&lt;/h1&gt;    &lt;form:form modelAttribute=&quot;student&quot;&gt;        学生ID：&lt;form:input path=&quot;id&quot;/&gt;&lt;br/&gt;        学生姓名：&lt;form:input path=&quot;name&quot;/&gt;&lt;br/&gt;        学生年龄：&lt;form:input path=&quot;age&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>1、JSP 页面导入 Spring MVC 表单标签库，与导入 JSTL 标签库的语法非常相似，前缀 prefix 可以自定义，通常定义为 from。</p><pre><code class="jsp">&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;</code></pre><p>2、将 form 表单与模型数据进行绑定，通过 modelAttribute 属性完成绑定，将 modelAttribute 的值设置为模型数据对应的 key 值。</p><pre><code class="java">Handeler:modelAndView.addObject(&quot;student&quot;,student);JSP:&lt;form:form modelAttribute=&quot;student&quot;&gt;</code></pre><p>3、form 表单完成绑定之后，将模型数据的值取出绑定到不同的标签中，通过设置标签的 path 属性完成，将 path 属性的值设置为模型数据对应的属性名即可。</p><pre><code class="jsp">学生ID：&lt;form:input path=&quot;id&quot;/&gt;&lt;br/&gt;学生姓名：&lt;form:input path=&quot;name&quot;/&gt;&lt;br/&gt;学生年龄：&lt;form:input path=&quot;age&quot;/&gt;&lt;br/&gt;</code></pre><h4 id="常用的表单标签"><a href="#常用的表单标签" class="headerlink" title="常用的表单标签"></a>常用的表单标签</h4><ul><li>from</li></ul><pre><code class="jsp">&lt;form:from modelAttribute=&quot;student&quot;/&gt;</code></pre><p>渲染的是 HTML 中的<code>&lt;form&gt;&lt;/from&gt;</code>，通过 modelAttribute 属性绑定具体的模型数据。</p><ul><li>input</li></ul><pre><code class="jsp">&lt;form:input path=&quot;name&quot;/&gt;</code></pre><p>渲染的是 HTML 中的 <code>&lt;input type=&quot;text&quot;/&gt;</code>，from 标签绑定的是模型数据，input 标签绑定的是模型数据中的属性值，通过 path 属性可以与模型数据中的属性名对应，并且支持及联操作。</p><pre><code class="jsp">&lt;from:input path=&quot;address.name&quot;/&gt;</code></pre><ul><li>password</li></ul><pre><code class="jsp">&lt;form:password path=&quot;password&quot;/&gt;</code></pre><p>渲染的是 HTML 中的 <code>&lt;input type=&quot;password&quot;/&gt;</code>，通过 path 属性与模型数据的属性值进行绑定，password 标签的值不会在页面显示。</p><ul><li>checkbox</li></ul><pre><code class="jsp">&lt;form:checkbox path=&quot;hobby&quot; value=&quot;读书&quot;/&gt;</code></pre><pre><code class="java">student.setFlag(false);</code></pre><pre><code class="jsp">checkbox：&lt;form:checkbox path=&quot;flag&quot; value=&quot;flag&quot;&gt;&lt;/form:checkbox&gt;&lt;br/&gt;</code></pre><p>渲染的是 HTML 中的 <code>&lt;input type=&quot;checkbox&quot;/&gt;</code>，通过 path 与模型数据的属性值进行绑定，可以绑定 boolean、数组和集合。</p><p>如果绑定 boolean 值，若该变量的值为 true，则表示该复选框选中，否则表示不选中。</p><p>如果绑定数组或者集合，数组&#x2F;集合中的元素等于 checkbox 的 value 值，则选中。</p><pre><code class="java">student.setHobby(Arrays.asList(&quot;读书&quot;,&quot;看电影&quot;,&quot;玩游戏&quot;));modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">爱好：&lt;form:checkbox path=&quot;hobby&quot; value=&quot;摄影&quot;&gt;&lt;/form:checkbox&gt;摄影&lt;br/&gt;&lt;form:checkbox path=&quot;hobby&quot; value=&quot;读书&quot;&gt;&lt;/form:checkbox&gt;读书&lt;br/&gt;&lt;form:checkbox path=&quot;hobby&quot; value=&quot;听音乐&quot;&gt;&lt;/form:checkbox&gt;听音乐&lt;br/&gt;&lt;form:checkbox path=&quot;hobby&quot; value=&quot;看电影&quot;&gt;&lt;/form:checkbox&gt;看电影&lt;br/&gt;&lt;form:checkbox path=&quot;hobby&quot; value=&quot;旅游&quot;&gt;&lt;/form:checkbox&gt;旅游&lt;br/&gt;&lt;form:checkbox path=&quot;hobby&quot; value=&quot;玩游戏&quot;&gt;&lt;/form:checkbox&gt;玩游戏&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</code></pre><ul><li>checkboxes</li></ul><pre><code class="jsp">&lt;form:checkboxes items=$&#123;student.hobby&#125; path=&quot;selecHobby&quot;/&gt;</code></pre><p>渲染的是 HTML 中的一组 <code>&lt;input type=&quot;checkbox&quot;/&gt;</code>，是对 <code>&lt;form:checkbox/&gt;</code> 的一种简化，需要结合 items 和 path 属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的集合或数组，可以这样理解，items 为全部可选集合，path 为默认的选中集合。</p><pre><code class="java">student.setHobby(Arrays.asList(&quot;摄影&quot;,&quot;读书&quot;,&quot;听音乐&quot;,&quot;看电影&quot;,&quot;旅游&quot;,&quot;玩游戏&quot;));student.setSelectHobby(Arrays.asList(&quot;摄影&quot;,&quot;读书&quot;,&quot;听音乐&quot;));modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">爱好：&lt;form:checkboxes path=&quot;selectHobby&quot; items=&quot;$&#123;student.hobby&#125;&quot;/&gt;&lt;br/&gt;</code></pre><p>需要注意的是 path 可以直接绑定模型数据的属性值，items 则需要通过 EL 表达式的形式从域对象中获取数据，不能直接写属性名。</p><ul><li>rabiobutton</li></ul><pre><code class="jsp">&lt;from:radiobutton path=&quot;radioId&quot; value=&quot;0&quot;/&gt;</code></pre><p>渲染的是 HTML 中的一个 <code>&lt;input type=&quot;radio&quot;/&gt;</code>，绑定的数据与标签的 value 值相等则为选中，否则不选中。</p><pre><code class="java">student.setRadioId(1);modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">radiobutton:&lt;form:radiobutton path=&quot;radioId&quot; value=&quot;1&quot;/&gt;radiobutton&lt;br/&gt;</code></pre><ul><li>radiobuttons</li></ul><pre><code class="jsp">&lt;form:radiobuttons itmes=&quot;$&#123;student.grade&#125;&quot; path=&quot;selectGrade&quot;/&gt;</code></pre><p>渲染的是 HTML 中的一组 <code>&lt;input type=&quot;radio&quot;/&gt;</code>，这里需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，items 为全部的可选类型，path 为默认选中的选项，用法与 <code>&lt;form:checkboxes/&gt;</code> 一致。</p><pre><code class="java">Map&lt;Integer,String&gt; gradeMap = new HashMap&lt;&gt;();gradeMap.put(1,&quot;一年级&quot;);gradeMap.put(2,&quot;二年级&quot;);gradeMap.put(3,&quot;三年级&quot;);gradeMap.put(4,&quot;四年级&quot;);gradeMap.put(5,&quot;五年级&quot;);gradeMap.put(6,&quot;六年级&quot;);student.setGradeMap(gradeMap);student.setSelectGrade(3);modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">学生年级：&lt;form:radiobuttons items=&quot;$&#123;student.gradeMap&#125;&quot; path=&quot;selectGrade&quot;/&gt;&lt;br/&gt;</code></pre><ul><li>select</li></ul><pre><code class="jsp">&lt;form:select items=&quot;$&#123;student.citys&#125;&quot; path=&quot;selectCity&quot;/&gt;</code></pre><p>渲染的是 HTML 中的一个 <code>&lt;select/&gt;</code> 标签，需要结合 items 和 path 两个属性来使用，items 绑定被遍历的集合或数组，path 绑定被选中的值，用法与 <code>&lt;from:radiobuttons/&gt;</code>一致。</p><pre><code class="java">Map&lt;Integer,String&gt; cityMap = new HashMap&lt;&gt;();cityMap.put(1,&quot;北京&quot;);cityMap.put(2,&quot;上海&quot;);cityMap.put(3,&quot;广州&quot;);cityMap.put(4,&quot;深圳&quot;);student.setCityMap(cityMap);student.setSelectCity(3);modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">所在城市：&lt;form:select items=&quot;$&#123;student.cityMap&#125;&quot; path=&quot;selectCity&quot;&gt;&lt;/form:select&gt;&lt;br/&gt;</code></pre><ul><li>options</li></ul><p><code>form:select</code> 结合 <code>form:options</code> 的使用，<code>from:select</code> 只定义 path 属性，在 <code>form:select</code> 标签内部添加一个子标签 <code>form:options</code> ，设置 items 属性，获取被遍历的集合。</p><pre><code class="jsp">所在城市：&lt;form:select path=&quot;selectCity&quot;&gt;                &lt;form:options items=&quot;$&#123;student.cityMap&#125;&quot;&gt;&lt;/form:options&gt;                &lt;/form:select&gt;&lt;br/&gt;</code></pre><ul><li><p>option</p><p><code>form:select</code> 结合 <code>form:option</code> 的使用，<code>from:select</code> 定义 path 属性，给每一个 <code>form:option</code> 设置 value 值，path 的值与哪个 value 值相等，该项默认选中。</p></li></ul><pre><code class="jsp">所在城市：&lt;form:select path=&quot;selectCity&quot;&gt;            &lt;form:option value=&quot;1&quot;&gt;杭州&lt;/form:option&gt;            &lt;form:option value=&quot;2&quot;&gt;成都&lt;/form:option&gt;            &lt;form:option value=&quot;3&quot;&gt;西安&lt;/form:option&gt;        &lt;/form:select&gt;&lt;br/&gt;</code></pre><ul><li>textarea</li></ul><p>渲染的是 HTML 中的一个 <code>&lt;textarea/&gt;</code> ，path 绑定模型数据的属性值，作为文本输入域的默认值。</p><pre><code class="java">student.setIntroduce(&quot;你好，我是...&quot;);modelAndView.addObject(&quot;student&quot;,student);</code></pre><pre><code class="jsp">信息：&lt;form:textarea path=&quot;introduce&quot;/&gt;&lt;br/&gt;</code></pre><ul><li>errors</li></ul><p>处理错误信息，一般用在数据校验，该标签需要结合 Spring MVC 的验证器结合起来使用。</p><h3 id="Spring-MVC-数据校验"><a href="#Spring-MVC-数据校验" class="headerlink" title="Spring MVC 数据校验"></a>Spring MVC 数据校验</h3><p>Spring MVC 提供了两种数据校验的方式：1、基于 Validator 接口。2、使用 Annotation JSR - 303 标准进行校验。</p><p>基于 Validator 接口的方式需要自定义 Validator 验证器，每一条数据的验证规则需要开发者手动完成，使用 Annotation JSR - 303 标准则不需要自定义验证器，通过注解的方式可以直接在实体类中添加每个属性的验证规则，这种方式更加方便，实际开发中推荐使用。</p><blockquote><p>基于 Validator 接口</p></blockquote><ul><li>实体类 Account</li></ul><pre><code class="java">package com.southwind.entity; import lombok.Data; @Datapublic class Account &#123;    private String name;    private String password;&#125;</code></pre><ul><li>自定义验证器 AccountValidator，实现 Validator 接口。</li></ul><pre><code class="java">package com.southwind.validator; import com.southwind.entity.Account;import org.springframework.validation.Errors;import org.springframework.validation.ValidationUtils;import org.springframework.validation.Validator; public class AccountValidator implements Validator &#123;    @Override    public boolean supports(Class&lt;?&gt; aClass) &#123;        return Account.class.equals(aClass);    &#125;     @Override    public void validate(Object o, Errors errors) &#123;        ValidationUtils.rejectIfEmpty(errors,&quot;name&quot;,null,&quot;姓名不能为空&quot;);        ValidationUtils.rejectIfEmpty(errors,&quot;password&quot;,null,&quot;密码不能为空&quot;);    &#125;&#125;</code></pre><ul><li>控制器</li></ul><pre><code class="java">package com.southwind.controller; import com.southwind.entity.Account;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.validation.annotation.Validated;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping; @Controller@RequestMapping(&quot;/validator&quot;)public class ValidatorHandler &#123;     @GetMapping(&quot;/login&quot;)    public String login(Model model)&#123;        model.addAttribute(&quot;account&quot;,new Account());        return &quot;login&quot;;    &#125;     @PostMapping(&quot;/login&quot;)    public String login(@Validated Account account, BindingResult bindingResult)&#123;        if(bindingResult.hasErrors())&#123;            return &quot;login&quot;;        &#125;        return &quot;index&quot;;    &#125;&#125;</code></pre><ul><li>springmvc.xml 配置验证器。</li></ul><pre><code class="xml">&lt;bean id=&quot;accountValidator&quot; class=&quot;com.southwind.validator.AccountValidator&quot;&gt;&lt;/bean&gt;&lt;mvc:annotation-driven validator=&quot;accountValidator&quot;&gt;&lt;/mvc:annotation-driven&gt;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-18  Time: 10:31  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%@ taglib prefix=&quot;from&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form:form modelAttribute=&quot;account&quot; action=&quot;/validator/login&quot; method=&quot;post&quot;&gt;        姓名：&lt;form:input path=&quot;name&quot;/&gt;&lt;from:errors path=&quot;name&quot;&gt;&lt;/from:errors&gt;&lt;br/&gt;        密码：&lt;form:input path=&quot;password&quot;/&gt;&lt;from:errors path=&quot;password&quot;&gt;&lt;/from:errors&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;    &lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>Annotation JSR - 303 标准</p></blockquote><p>使用 Annotation JSR - 303 标准进行验证，需要导入支持这种标准的依赖 jar 文件，这里我们使用 Hibernate Validator。</p><ul><li>pom.xml</li></ul><pre><code class="xml">&lt;!-- JSR-303 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;  &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;  &lt;version&gt;5.3.6.Final&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt;  &lt;groupId&gt;javax.validation&lt;/groupId&gt;  &lt;artifactId&gt;validation-api&lt;/artifactId&gt;  &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt;  &lt;groupId&gt;org.jboss.logging&lt;/groupId&gt;  &lt;artifactId&gt;jboss-logging&lt;/artifactId&gt;  &lt;version&gt;3.3.2.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre><ul><li>通过注解的方式直接在实体类中添加相关的验证规则。</li></ul><pre><code class="java">package com.southwind.entity; import lombok.Data;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.NotEmpty;import javax.validation.constraints.Pattern;import javax.validation.constraints.Size; @Datapublic class Person &#123;    @NotEmpty(message = &quot;用户名不能为空&quot;)    private String username;    @Size(min = 6,max = 12,message = &quot;密码6-12位&quot;)    private String password;    @Email(regexp = &quot;^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\\\.[a-zA-Z0-9-]+)*\\\\.[a-zA-Z0-9]&#123;2,6&#125;$&quot;,message = &quot;请输入正确的邮箱格式&quot;)    private String email;    @Pattern(regexp = &quot;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\\\\\\\\d&#123;8&#125;$&quot;,message = &quot;请输入正确的电话&quot;)    private String phone;&#125;</code></pre><ul><li>ValidatorHandler</li></ul><pre><code class="java">@GetMapping(&quot;/register&quot;)public String register(Model model)&#123;    model.addAttribute(&quot;person&quot;,new Person());    return &quot;register&quot;;&#125; @PostMapping(&quot;/register&quot;)public String register(@Valid Person person, BindingResult bindingResult)&#123;    if(bindingResult.hasErrors())&#123;        return &quot;register&quot;;    &#125;    return &quot;index&quot;;&#125;</code></pre><ul><li>springmvc.xml</li></ul><pre><code class="xml">&lt;mvc:annotation-driven /&gt;</code></pre><ul><li>JSP</li></ul><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: southwind  Date: 2019-03-18  Time: 11:29  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form:form modelAttribute=&quot;person&quot; action=&quot;/validator/register2&quot; method=&quot;post&quot;&gt;        用户名：&lt;form:input path=&quot;username&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;username&quot;/&gt;&lt;br/&gt;        密码：&lt;form:password path=&quot;password&quot;&gt;&lt;/form:password&gt;&lt;form:errors path=&quot;password&quot;/&gt;&lt;br/&gt;        邮箱：&lt;form:input path=&quot;email&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;email&quot;/&gt;&lt;br/&gt;        电话：&lt;form:input path=&quot;phone&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;phone&quot;/&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;    &lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>校验规则详解：</p><p>@Null                   被注解的元素必须为null</p><p>@NotNull                  被注解的元素不能为null</p><p>@Min(value)              被注解的元素必须是一个数字，其值必须大于等于指定的最小值</p><p>@Max(value)             被注解的元素必须是一个数字，其值必须小于于等于指定的最大值   </p><p>@Email                   被注解的元素必须是电子邮箱地址</p><p>@Pattern                  被注解的元素必须符合对应的正则表达式</p><p>@Length                被注解的元素的大小必须在指定的范围内</p><p>@NotEmpty                 被注解的字符串的值必须非空</p><p>Null 和 Empty 是不同的结果，String str &#x3D; null，str 是 null，String str &#x3D; “”，str 不是 null，其值为空。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-MVC&quot;&gt;&lt;a href=&quot;#Spring-MVC&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC&quot;&gt;&lt;/a&gt;Spring MVC&lt;/h3&gt;&lt;p&gt;Spring MVC 是目前主流的实现 MVC 设计模式的企业级开发框架，S</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="springMVC" scheme="http://example.com/tags/springMVC/"/>
    
  </entry>
  
  <entry>
    <title>spring学习</title>
    <link href="http://example.com/2023/11/29/spring/"/>
    <id>http://example.com/2023/11/29/spring/</id>
    <published>2023-11-29T13:35:14.020Z</published>
    <updated>2023-11-29T13:36:28.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-框架两大核心机制（IoC、AOP）"><a href="#Spring-框架两大核心机制（IoC、AOP）" class="headerlink" title="Spring 框架两大核心机制（IoC、AOP）"></a>Spring 框架两大核心机制（IoC、AOP）</h3><ul><li>IoC（控制反转）&#x2F; DI（依赖注入）</li><li>AOP（面向切面编程）</li></ul><p>Spring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p><p>MVC：Struts2、Spring MVC</p><p>ORMapping：Hibernate、MyBatis、Spring Data</p><h3 id="如何使用-IoC"><a href="#如何使用-IoC" class="headerlink" title="如何使用 IoC"></a>如何使用 IoC</h3><ul><li>创建 Maven 工程，pom.xml 添加依赖</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;     &lt;groupId&gt;com.southwind&lt;/groupId&gt;    &lt;artifactId&gt;aispringioc&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;     &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt; &lt;/project&gt;</code></pre><ul><li>创建实体类 Student</li></ul><pre><code class="java">package com.southwind.entity; import lombok.Data; @Datapublic class Student &#123;    private long id;    private String name;    private int age;&#125;</code></pre><ul><li>传统的开发方式，手动 new Student</li></ul><pre><code class="java">Student student = new Student();student.setId(1L);student.setName(&quot;张三&quot;);student.setAge(22);System.out.println(student);</code></pre><ul><li>通过 IoC 创建对象，在配置文件中添加需要管理的对象，XML 格式的配置文件，文件名可以自定义。</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;     &lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot;&gt;        &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;    &lt;/bean&gt; &lt;/beans&gt;</code></pre><ul><li>从 IoC 中获取对象，通过 id 获取。</li></ul><pre><code class="java">//加载配置文件ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);Student student = (Student) applicationContext.getBean(&quot;student&quot;);System.out.println(student);</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>通过配置 <code>bean</code> 标签来完成对象的管理。</p><ul><li><p><code>id</code>：对象名。</p></li><li><p><code>class</code>：对象的模版类（所有交给 IoC 容器来管理的类必须有无参构造函数，因为 Spring 底层是通过反射机制来创建对象，调用的是无参构造）</p></li></ul></li><li><p>对象的成员变量通过 <code>property</code> 标签完成赋值。</p><ul><li><code>name</code>：成员变量名。</li><li><code>value</code>：成员变量值（基本数据类型，String 可以直接赋值，如果是其他引用类型，不能通过 value 赋值）</li><li><code>ref</code>：将 IoC 中的另外一个 bean 赋给当前的成员变量（DI）</li></ul><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;com.southwind.entity.Address&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;科技路&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre></li></ul><h3 id="IoC-底层原理"><a href="#IoC-底层原理" class="headerlink" title="IoC 底层原理"></a>IoC 底层原理</h3><ul><li>读取配置文件，解析 XML。</li><li>通过反射机制实例化配置文件中所配置所有的 bean。</li></ul><pre><code class="java">package com.southwind.ioc; import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader; import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Iterator;import java.util.Map; public class ClassPathXmlApplicationContext implements ApplicationContext &#123;    private Map&lt;String,Object&gt; ioc = new HashMap&lt;String, Object&gt;();    public ClassPathXmlApplicationContext(String path)&#123;        try &#123;            SAXReader reader = new SAXReader();            Document document = reader.read(&quot;./src/main/resources/&quot;+path);            Element root = document.getRootElement();            Iterator&lt;Element&gt; iterator = root.elementIterator();            while(iterator.hasNext())&#123;                Element element = iterator.next();                String id = element.attributeValue(&quot;id&quot;);                String className = element.attributeValue(&quot;class&quot;);                //通过反射机制创建对象                Class clazz = Class.forName(className);                //获取无参构造函数，创建目标对象                Constructor constructor = clazz.getConstructor();                Object object = constructor.newInstance();                //给目标对象赋值                Iterator&lt;Element&gt; beanIter = element.elementIterator();                while(beanIter.hasNext())&#123;                    Element property = beanIter.next();                    String name = property.attributeValue(&quot;name&quot;);                    String valueStr = property.attributeValue(&quot;value&quot;);                    String ref = property.attributeValue(&quot;ref&quot;);                    if(ref == null)&#123;                        String methodName = &quot;set&quot;+name.substring(0,1).toUpperCase()+name.substring(1);                        Field field = clazz.getDeclaredField(name);                        Method method = clazz.getDeclaredMethod(methodName,field.getType());                        //根据成员变量的数据类型将 value 进行转换                        Object value = null;                        if(field.getType().getName() == &quot;long&quot;)&#123;                            value = Long.parseLong(valueStr);                        &#125;                        if(field.getType().getName() == &quot;java.lang.String&quot;)&#123;                            value = valueStr;                        &#125;                        if(field.getType().getName() == &quot;int&quot;)&#123;                            value = Integer.parseInt(valueStr);                        &#125;                        method.invoke(object,value);                    &#125;                    ioc.put(id,object);                &#125;            &#125;        &#125; catch (DocumentException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e)&#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e)&#123;            e.printStackTrace();        &#125; catch (InstantiationException e)&#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e)&#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e)&#123;            e.printStackTrace();        &#125; catch (NoSuchFieldException e)&#123;            e.printStackTrace();        &#125;    &#125;     public Object getBean(String id) &#123;        return ioc.get(id);    &#125;&#125;</code></pre><h3 id="通过运行时类获取-bean"><a href="#通过运行时类获取-bean" class="headerlink" title="通过运行时类获取 bean"></a>通过运行时类获取 bean</h3><pre><code class="java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);Student student = (Student) applicationContext.getBean(Student.class);System.out.println(student);</code></pre><p>这种方式存在一个问题，配置文件中一个数据类型的对象只能有一个实例，否则会抛出异常，因为没有唯一的 bean。</p><h3 id="通过有参构造创建-bean"><a href="#通过有参构造创建-bean" class="headerlink" title="通过有参构造创建 bean"></a>通过有参构造创建 bean</h3><ul><li>在实体类中创建对应的有参构造函数。</li><li>配置文件</li></ul><pre><code class="xml">&lt;bean id=&quot;student3&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;constructor-arg name=&quot;id&quot; value=&quot;3&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;name&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><pre><code class="xml">&lt;bean id=&quot;student3&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;constructor-arg index=&quot;0&quot; value=&quot;3&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg index=&quot;2&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg index=&quot;1&quot; value=&quot;小明&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg index=&quot;3&quot; ref=&quot;address&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="给-bean-注入集合"><a href="#给-bean-注入集合" class="headerlink" title="给 bean 注入集合"></a>给 bean 注入集合</h3><pre><code class="xml">&lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;33&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;addresses&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;address&quot;&gt;&lt;/ref&gt;            &lt;ref bean=&quot;address2&quot;&gt;&lt;/ref&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;com.southwind.entity.Address&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;科技路&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.southwind.entity.Address&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;高新区&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h3 id="scope-作用域"><a href="#scope-作用域" class="headerlink" title="scope 作用域"></a>scope 作用域</h3><p>Spring 管理的 bean 是根据 scope 来生成的，表示 bean 的作用域，共4种，默认值是 singleton。</p><ul><li>singleton：单例，表示通过 IoC 容器获取的 bean 是唯一的。</li><li>prototype：原型，表示通过 IoC 容器获取的 bean 是不同的。</li><li>request：请求，表示在一次 HTTP 请求内有效。</li><li>session：回话，表示在一个用户会话内有效。</li></ul><p>request 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。</p><p>prototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。</p><p>singleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。</p><h3 id="Spring-的继承"><a href="#Spring-的继承" class="headerlink" title="Spring 的继承"></a>Spring 的继承</h3><p>与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。</p><pre><code class="xml">&lt;bean id=&quot;student2&quot; class=&quot;com.southwind.entity.Student&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;22&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;addresses&quot;&gt;        &lt;list&gt;            &lt;ref bean=&quot;address&quot;&gt;&lt;/ref&gt;            &lt;ref bean=&quot;address2&quot;&gt;&lt;/ref&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;com.southwind.entity.Address&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;科技路&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.southwind.entity.Address&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;高新区&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.southwind.entity.Student&quot; parent=&quot;student2&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;李四&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>Spring 的继承关注点在于具体的对象，而不在于类，即不同的两个类的实例化对象可以完成继承，前提是子对象必须包含父对象的所有属性，同时可以在此基础上添加其他的属性。</p><h3 id="Spring-的依赖"><a href="#Spring-的依赖" class="headerlink" title="Spring 的依赖"></a>Spring 的依赖</h3><p>与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean，A 依赖于 B，先创建 B，再创建 A。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd                           &quot;&gt;     &lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot; depends-on=&quot;user&quot;&gt;&lt;/bean&gt;     &lt;bean id=&quot;user&quot; class=&quot;com.southwind.entity.User&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;</code></pre><h3 id="Spring-的-p-命名空间"><a href="#Spring-的-p-命名空间" class="headerlink" title="Spring 的 p 命名空间"></a>Spring 的 p 命名空间</h3><p>p 命名空间是对 IoC &#x2F; DI 的简化操作，使用 p 命名空间可以更加方便的完成 bean 的配置以及 bean 之间的依赖注入。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;     &lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot; p:id=&quot;1&quot; p:name=&quot;张三&quot; p:age=&quot;22&quot; p:address-ref=&quot;address&quot;&gt;&lt;/bean&gt;     &lt;bean id=&quot;address&quot; class=&quot;com.southwind.entity.Address&quot; p:id=&quot;2&quot; p:name=&quot;科技路&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;</code></pre><h3 id="Spring-的工厂方法"><a href="#Spring-的工厂方法" class="headerlink" title="Spring 的工厂方法"></a>Spring 的工厂方法</h3><p>IoC 通过工厂模式创建 bean 的方式有两种：</p><ul><li>静态工厂方法</li><li>实例工厂方法</li></ul><blockquote><p>静态工厂方法</p></blockquote><pre><code class="java">package com.southwind.entity; import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor; @Data@AllArgsConstructor@NoArgsConstructorpublic class Car &#123;    private long id;    private String name;&#125;</code></pre><pre><code class="java">package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap;import java.util.Map; public class StaticCarFactory &#123;    private static Map&lt;Long, Car&gt; carMap;    static&#123;        carMap = new HashMap&lt;Long, Car&gt;();        carMap.put(1L,new Car(1L,&quot;宝马&quot;));        carMap.put(2L,new Car(2L,&quot;奔驰&quot;));    &#125;     public static Car getCar(long id)&#123;        return carMap.get(id);    &#125;&#125;</code></pre><pre><code class="xml">&lt;!-- 配置静态工厂创建 Car --&gt;&lt;bean id=&quot;car&quot; class=&quot;com.southwind.factory.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;    &lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><blockquote><p>实例工厂方法</p></blockquote><pre><code class="java">package com.southwind.factory; import com.southwind.entity.Car; import java.util.HashMap;import java.util.Map; public class InstanceCarFactory &#123;    private Map&lt;Long, Car&gt; carMap;    public InstanceCarFactory()&#123;        carMap = new HashMap&lt;Long, Car&gt;();        carMap.put(1L,new Car(1L,&quot;宝马&quot;));        carMap.put(2L,new Car(2L,&quot;奔驰&quot;));    &#125;     public Car getCar(long id)&#123;        return carMap.get(id);    &#125;&#125;</code></pre><pre><code class="xml">&lt;!-- 配置实例工厂 bean --&gt;&lt;bean id=&quot;carFactory&quot; class=&quot;com.southwind.factory.InstanceCarFactory&quot;&gt;&lt;/bean&gt; &lt;!-- 赔偿实例工厂创建 Car --&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt;    &lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="IoC-自动装载（Autowire）"><a href="#IoC-自动装载（Autowire）" class="headerlink" title="IoC 自动装载（Autowire）"></a>IoC 自动装载（Autowire）</h3><p>IoC 负责创建对象，DI 负责完成对象的依赖注入，通过配置 property 标签的 ref 属性来完成，同时 Spring 提供了另外一种更加简便的依赖注入方式：自动装载，不需要手动配置 property，IoC 容器会自动选择 bean 完成注入。</p><p>自动装载有两种方式：</p><ul><li>byName：通过属性名自动装载</li><li>byType：通过属性的数据类型自动装载</li></ul><blockquote><p>byName</p></blockquote><pre><code class="xml">&lt;bean id=&quot;cars&quot; class=&quot;com.southwind.entity.Car&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;宝马&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.southwind.entity.Person&quot; autowire=&quot;byName&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;11&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><blockquote><p>byType</p></blockquote><pre><code class="xml">&lt;bean id=&quot;car&quot; class=&quot;com.southwind.entity.Car&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;2&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.southwind.entity.Person&quot; autowire=&quot;byType&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;11&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>byType 需要注意，如果同时存在两个及以上的符合条件的 bean 时，自动装载会抛出异常。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP：Aspect Oriented Programming 面向切面编程。</p><p>AOP 的优点：</p><ul><li>降低模块之间的耦合度。</li><li>使系统更容易扩展。</li><li>更好的代码复用。</li><li>非业务代码更加集中，不分散，便于统一管理。</li><li>业务代码更加简洁存粹，不参杂其他代码的影响。</li></ul><p>AOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就是 AOP。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>创建 Maven 工程，pom.xml 添加</li></ul><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;    &lt;/dependency&gt;         &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;    &lt;/dependency&gt;     &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li>创建一个计算器接口 Cal，定义4个方法。</li></ul><pre><code class="java">package com.southwind.utils; public interface Cal &#123;    public int add(int num1,int num2);    public int sub(int num1,int num2);    public int mul(int num1,int num2);    public int div(int num1,int num2);&#125;</code></pre><ul><li>创建接口的实现类 CalImpl。</li></ul><pre><code class="java">package com.southwind.utils.impl; import com.southwind.utils.Cal; public class CalImpl implements Cal &#123;    public int add(int num1, int num2) &#123;        System.out.println(&quot;add方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1+num2;        System.out.println(&quot;add方法的结果是&quot;+result);        return result;    &#125;     public int sub(int num1, int num2) &#123;        System.out.println(&quot;sub方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1-num2;        System.out.println(&quot;sub方法的结果是&quot;+result);        return result;    &#125;     public int mul(int num1, int num2) &#123;        System.out.println(&quot;mul方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1*num2;        System.out.println(&quot;mul方法的结果是&quot;+result);        return result;    &#125;     public int div(int num1, int num2) &#123;        System.out.println(&quot;div方法的参数是[&quot;+num1+&quot;,&quot;+num2+&quot;]&quot;);        int result = num1/num2;        System.out.println(&quot;div方法的结果是&quot;+result);        return result;    &#125;&#125;</code></pre><p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用 AOP 可以进行优化，如何来实现 AOP？使用动态代理的方式来实现。</p><p>给业务代码找一个代理，打印日志信息的工作交个代理来做，这样的话业务代码就只需要关注自身的业务即可。</p><pre><code class="java">package com.southwind.utils; import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays; public class MyInvocationHandler implements InvocationHandler &#123;    //接收委托对象    private Object object = null;     //返回代理对象    public Object bind(Object object)&#123;        this.object = object;        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);    &#125;     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(method.getName()+&quot;方法的参数是：&quot;+ Arrays.toString(args));        Object result = method.invoke(this.object,args);        System.out.println(method.getName()+&quot;的结果是&quot;+result);        return result;    &#125;&#125;</code></pre><p>以上是通过动态代理实现 AOP 的过程，比较复杂，不好理解，Spring 框架对 AOP 进行了封装，使用 Spring 框架可以用面向对象的思想来实现 AOP。</p><p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成即可，Spring 框架底层会自动根据切面类以及目标类生成一个代理对象。</p><p>LoggerAspect</p><pre><code class="java">package com.southwind.aop; import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component; import java.util.Arrays; @Aspect@Componentpublic class LoggerAspect &#123;     @Before(value = &quot;execution(public int com.southwind.utils.impl.CalImpl.*(..))&quot;)    public void before(JoinPoint joinPoint)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        //获取参数        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(name+&quot;方法的参数是：&quot;+ args);    &#125;     @After(value = &quot;execution(public int com.southwind.utils.impl.CalImpl.*(..))&quot;)    public void after(JoinPoint joinPoint)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法执行完毕&quot;);    &#125;     @AfterReturning(value = &quot;execution(public int com.southwind.utils.impl.CalImpl.*(..))&quot;,returning = &quot;result&quot;)    public void afterReturning(JoinPoint joinPoint,Object result)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法的结果是&quot;+result);    &#125;     @AfterThrowing(value = &quot;execution(public int com.southwind.utils.impl.CalImpl.*(..))&quot;,throwing = &quot;exception&quot;)    public void afterThrowing(JoinPoint joinPoint,Exception exception)&#123;        //获取方法名        String name = joinPoint.getSignature().getName();        System.out.println(name+&quot;方法抛出异常：&quot;+exception);    &#125; &#125;</code></pre><p>LoggerAspect 类定义处添加的两个注解：</p><ul><li><code>@Aspect</code>：表示该类是切面类。</li><li><code>@Component</code>：将该类的对象注入到 IoC 容器。</li></ul><p>具体方法处添加的注解：</p><p><code>@Before</code>：表示方法执行的具体位置和时机。</p><p>CalImpl 也需要添加 <code>@Component</code>，交给 IoC 容器来管理。</p><pre><code class="java">package com.southwind.utils.impl; import com.southwind.utils.Cal;import org.springframework.stereotype.Component; @Componentpublic class CalImpl implements Cal &#123;    public int add(int num1, int num2) &#123;        int result = num1+num2;        return result;    &#125;     public int sub(int num1, int num2) &#123;        int result = num1-num2;        return result;    &#125;     public int mul(int num1, int num2) &#123;        int result = num1*num2;        return result;    &#125;     public int div(int num1, int num2) &#123;        int result = num1/num2;        return result;    &#125;&#125;</code></pre><p>spring.xml 中配置 AOP。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;     &lt;!-- 自动扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.southwind&quot;&gt;&lt;/context:component-scan&gt;     &lt;!-- 是Aspect注解生效，为目标类自动生成代理对象 --&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt;</code></pre><p><code>context:component-scan</code> 将 <code>com.southwind</code> 包中的所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类扫描到 IoC 容器中，即 IoC 管理它的对象。</p><p><code>aop:aspectj-autoproxy</code> 让 Spring 框架结合切面类和目标类自动生成动态代理对象。</p><ul><li>切面：横切关注点被模块化的抽象对象。</li><li>通知：切面对象完成的工作。</li><li>目标：被通知的对象，即被横切的对象。</li><li>代理：切面、通知、目标混合之后的对象。</li><li>连接点：通知要插入业务代码的具体位置。</li><li>切点：AOP 通过切点定位到连接点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Spring-框架两大核心机制（IoC、AOP）&quot;&gt;&lt;a href=&quot;#Spring-框架两大核心机制（IoC、AOP）&quot; class=&quot;headerlink&quot; title=&quot;Spring 框架两大核心机制（IoC、AOP）&quot;&gt;&lt;/a&gt;Spring 框架两大核心机</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JS数组知识点梳理</title>
    <link href="http://example.com/2023/11/24/Array/"/>
    <id>http://example.com/2023/11/24/Array/</id>
    <published>2023-11-24T05:40:15.038Z</published>
    <updated>2023-11-24T05:43:39.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js数组篇"><a href="#js数组篇" class="headerlink" title="js数组篇"></a>js数组篇</h1><h2 id="一、创建数组"><a href="#一、创建数组" class="headerlink" title="一、创建数组"></a>一、创建数组</h2><pre><code>let colors=new array（20）；</code></pre><p>20代表了数组的length属性，可以自动确定数组的长度。<br>也可以不填，即<code>let colors=new array（）；</code><br>也可以给array构造函数传入要保存的元素。</p><pre><code>let colors=new array（&quot;red&quot;,&quot;yellow,&quot;blue&quot;）；</code></pre><p>如果没有传入，也可以后续传入</p><pre><code>let colors=[&quot;red&quot;,&quot;yellow,&quot;blue&quot;];</code></pre><p>Array构造函数还有两个ES6新增创建数组的静态方法from()和of();<br><strong>from():将类数组结构转换成数组实例</strong></p><ul><li>字符串会拆分成单字符数组Array.from（“Matt”）&#x2F;&#x2F;[“M”，“a”,“t”,“t”]</li><li>将集合和映射转换成一个新的数组</li></ul><pre><code>const m=new map().set(1,2)                                .set(1,2);clg(Array.from(m));//[[1,2],[3,4]]</code></pre><ul><li>对现有数组浅复制</li></ul><pre><code>const a1=[1,2,3,4];const a2=Array.from(a1);clg(a1);//[1,2,3,4]clg(a1===a2)//false;</code></pre><ul><li>使用任何可迭代对象</li><li>还可以接收第二个可选的映射函数参数</li></ul><p><strong>of（）</strong></p><ul><li>可以把一组参数转换为数组，<br>代替ES6之前的Array.propotype.slice.call(argument)</li></ul><pre><code>clg(Array.of(1,2,3,4))//[1,2,3,4]</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js数组篇&quot;&gt;&lt;a href=&quot;#js数组篇&quot; class=&quot;headerlink&quot; title=&quot;js数组篇&quot;&gt;&lt;/a&gt;js数组篇&lt;/h1&gt;&lt;h2 id=&quot;一、创建数组&quot;&gt;&lt;a href=&quot;#一、创建数组&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手及四次挥手</title>
    <link href="http://example.com/2023/11/06/tcp/"/>
    <id>http://example.com/2023/11/06/tcp/</id>
    <published>2023-11-06T06:45:55.691Z</published>
    <updated>2023-11-06T12:16:14.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#three">三次握手</a></li></ol></li><li><ol start="2"><li><a href="#four">四次挥手</a></li></ol></li><li><ol start="3"><li><a href="#http">http与https的区别</a></li></ol></li><li><ol start="4"><li><a href="#diff">HTTP GET 和POST</a></li></ol></li><li><a href="#link">相关链接</a><!-- vscode-markdown-toc-config numbering=true autoSave=true /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --></li></ul><h1 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a><a name='three'></a>什么是三次握手？</h1><p>先认识几个定义：</p><ul><li>SYN：同步序列编号，是TCP&#x2F;IP建立连接时使用的握手信号。在客户机和服务器之间建立TCP连接时，先发送的信号，客户端在接收到SYN信息时，就会在自己的段内生成一个随机值</li><li>SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。</li><li>ACK： 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。</li></ul><p>三次握手：<br>三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><ul><li><p>第一次握手([SYN], Seq &#x3D; x)<br>客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。</p></li><li><p>第二次握手([SYN,ACK], Seq &#x3D; y, ACK &#x3D; x + 1)<br>服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK &#x3D; x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq &#x3D; y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手([ACK], ACK &#x3D; y + 1)<br>客户端再次发送确认包(ACK),ACK &#x3D; y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。</p></li></ul><p><img src="/pic/tcp_1.png" alt="tcp" title="tcp"><br>可以看成生活中的打电话：</p><ul><li>小明 - 客户端 小红 - 服务端</li><li>小明给小红打电话，接通了后，小明说喂，能听到吗，这就相当于是连接建立。</li><li>小红给小明回应，能听到，你能听到我说的话吗，这就相当于是请求响应。</li><li>小明听到小红的回应后，好的，这相当于是连接确认。在这之后小明和小红就可以通话&#x2F;交换信息了</li></ul><h1 id="什么时候四次挥手？"><a href="#什么时候四次挥手？" class="headerlink" title="什么时候四次挥手？"></a><a name='four'></a>什么时候四次挥手？</h1><p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面我们来描述一下这个过程。</p><p>TCP连接的断开需要发送四个包，所以称为四次挥手。</p><ul><li><p>第一次挥手（[FIN], Seq &#x3D; x）<br>客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。</p></li><li><p>第二次挥手 ([ACK], ACK &#x3D; x + 1)<br>服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。</p></li><li><p>第三次挥手 ([FIN], Seq &#x3D; y)<br>服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。</p></li><li><p>第四次挥手 ([ACK], ACK &#x3D; y + 1)<br>客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。<br>服务端接收到ACK包后，关闭连接，进入CLOSED状态。<br>客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。<br><img src="/pic/tcp_2.png" alt="tcp" title="tcp"></p></li></ul><p>可以看成生活中的打电话：</p><ul><li>小明 - 客户端 小红 - 服务端</li><li>小明对小红说，我所有的东西都说完了，我要挂电话了。</li><li>小红说，收到，我这边还有一些东西没说。</li><li>经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了</li><li>小明收到消息后，又等了若干时间后，挂断了电话。</li></ul><h1 id="http与https的区别？"><a href="#http与https的区别？" class="headerlink" title="http与https的区别？"></a><a name='http'></a>http与https的区别？</h1><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。<br>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。<br>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。<br>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>而 HTTPS 的全称是 Hypertext Transfer Protocol Secure，从名称我们可以看出 HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS&#x2F;SSL 协议组合而成，而安全性的保证正是 TLS&#x2F;SSL 所做的工作。</p><p>也就是说，HTTPS 就是身披了一层 SSL 的 HTTP。<br>那么，HTTP 和 HTTPS 的主要区别是什么呢？</p><p>最简单的，HTTP 在地址栏上的协议是以 http:&#x2F;&#x2F; 开头，而 HTTPS 在地址栏上的协议是以 https:&#x2F;&#x2F; 开头</p><pre><code class="js"> http://www.cxuanblog.com/  https://www.cxuanblog.com/ </code></pre><p>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。</p><p>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</p><h1 id="HTTP-GET-和POST的区别？"><a href="#HTTP-GET-和POST的区别？" class="headerlink" title="HTTP GET 和POST的区别？"></a><a name='diff'></a>HTTP GET 和POST的区别？</h1><p>HTTP 中包括许多方法，Get 和 Post 是 HTTP 中最常用的两个方法，基本上使用 HTTP 方法中有 99% 都是在使用 Get 方法和 Post 方法，所以有必要我们对这两个方法有更加深刻的认识。</p><p>get 方法一般用于请求，比如你在浏览器地址栏输入 <a href="http://www.cxuanblog.com/">www.cxuanblog.com</a> 其实就是发送了一个 get 请求，它的主要特征是请求服务器返回资源，而 post 方法一般用于 <form> 表单的提交，相当于是把信息提交给服务器，等待服务器作出响应，get 相当于一个是 pull&#x2F;拉的操作，而 post 相当于是一个 push&#x2F;推的操作。<br>get 方法是不安全的，因为你在发送请求的过程中，你的请求参数会拼在 URL 后面，从而导致容易被攻击者窃取，对你的信息造成破坏和伪造；</p><pre><code class="js"> /test/demo_form.asp?name1=value1&amp;name2=value2 </code></pre><p>而 post 方法是把参数放在请求体 body 中的，这对用户来说不可见。</p><pre><code class="js"> POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 </code></pre><ul><li>get 请求的 URL 有长度限制，而 post 请求会把参数和值放在消息体中，对数据长度没有要求。</li><li>get 请求会被浏览器主动 cache，而 post 不会，除非手动设置。</li><li>get 请求在浏览器反复的 回退&#x2F;前进 操作是无害的，而 post 操作会再次提交表单请求。</li><li>get 请求在发送过程中会产生一个 TCP 数据包；post 在发送过程中会产生两个 TCP 数据包。对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；而对于 post，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li></ul><h1 id="link"><a href="#link" class="headerlink" title="link"></a><a name='link'></a>link</h1><p>[<a href="https://www.jianshu.com/p/12790cea57ac]">https://www.jianshu.com/p/12790cea57ac]</a><br>[<a href="https://zhuanlan.zhihu.com/p/135947893]">https://zhuanlan.zhihu.com/p/135947893]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文章目录&quot;&gt;&lt;a href=&quot;#文章目录&quot; class=&quot;headerlink&quot; title=&quot;文章目录&quot;&gt;&lt;/a&gt;文章目录&lt;/h1&gt;&lt;!-- vscode-markdown-toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#three&quot;&gt;三</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>DOM&amp;&amp;BOM知识点梳理</title>
    <link href="http://example.com/2023/11/01/DOM/"/>
    <id>http://example.com/2023/11/01/DOM/</id>
    <published>2023-11-01T12:52:59.972Z</published>
    <updated>2023-11-03T12:06:24.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DOM知识点"><a href="#DOM知识点" class="headerlink" title="DOM知识点"></a>DOM知识点</h1><h2 id="DOM概念"><a href="#DOM概念" class="headerlink" title="DOM概念"></a>DOM概念</h2><p>在掘金上看到一个很好的解释-DOM</p><ul><li><p>D,代表文档<br>如果没有文档，DOM也就无从谈起，当你创建的网页加载到浏览器时，DOM在幕后就悄然而生，此时你的这个<strong>网页文档就是一个文档对象</strong>，也就是DOM中的D.</p></li><li><p>O,代表对象<br>O代表的就是宿主对象，也就是浏览器给我们提供的这部分对象。</p></li><li><p>M，代表模型<br>这里首先要知道字面的模型是什么意思？生活中我们常见的模型主要有飞机模型，汽车模型，人体模型等，不管是什么模型，他们都是某种事物的表现形式。就像飞机模型代表着一架真正的飞机，一张城市地图代表着某一座城市一样。那么，在这里的模型就指的是我们这个网页，这个网页里的各种HTML元素都是构成这个模型的组件，他们相互包含又相互并列存在，构成一种父子、兄弟的关系，也就类似于一棵树的各个分支一样，许多的分支组成了这一棵树，这棵树就是一个模型。</p></li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><h3 id="节点概念"><a href="#节点概念" class="headerlink" title="节点概念"></a>节点概念</h3><p>一个html标签标识了整个文档的开始，这个网页里的所有其他元素都包含在这个标签当中。均可以用父子、兄弟关系来描述这样一个网页，构成这些父子兄弟的元素分隔点，我们就称其为节点。</p><h3 id="节点分类"><a href="#节点分类" class="headerlink" title="节点分类"></a>节点分类</h3><ul><li><p>元素节点<br>&lt;\h1&gt;、&lt;\p&gt;、&lt;\ul&gt;这些元素就被成为元素节点。</p></li><li><p>文本节点<br>在一个网页中大部分的内容都由文本来提供，如这个网页里 p 标签所包含的那段文字，他就是一个文本节点，一般网页里的文本节点总是被包含在元素节点内部，但不是所有的元素节点都包含文本节点。</p></li><li><p>属性节点<br>属性节点是元素节点的更具体描述，例如可以描述出他的类型，说明等，比如大部分元素都具备title属性，这个属性就是用来对每个元素的内容加以说明，这个节点就是属性节点。</p></li></ul><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;节点的概念&lt;/title&gt;&lt;/head&gt;&lt;body&gt;     &lt;h1&gt;这是一个标题&lt;/h1&gt;    &lt;p title=&quot;这段文字的说明&quot;&gt;这是一段文字说明，也是一个段落&lt;/p&gt;    &lt;p&gt;测试数据&lt;/p&gt;    &lt;ul id=&quot;purchases&quot;&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;        &lt;li class=&quot;sale&quot;&gt;这是一个列表&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>1.通过元素节点的id&#x2F;class属性去获取</p><pre><code class="js">document.getElementById(id)// 语法document.getElementsByClassName(&quot;class&quot;)</code></pre><p>2.通过元素获取，它返回的是一个对象的数组</p><pre><code class="js">var Uli = document.getElementsByTagName(li)var count = Uli.lengthconsole.log(count)&gt; 4for(var i=0; i&lt;count; i++)&#123;    // 弹出四次Object,返回的是一个对象数组    alert(typeof Uli[i])&#125;</code></pre><p>3.通过css选择器获取元素</p><pre><code class="js">// 获取文档中 id=&quot;purchases&quot; 的元素：document.querySelector(&#39;#purchases&#39;)// 获取文档中第一个P元素document.querySelector(&quot;p&quot;)// 获取文档中class=&quot;sale&quot;的第一个P元素document.querySelector(&quot;p.sale&quot;)// 获取文档中有p元素有title属性的第一个p元素document.querySelector(&quot;p[title]&quot;)/**以下实例演示了多个选择器的使用方法。假定你选择了两个选择器: &lt;h2&gt; 和 &lt;h3&gt; 元素。以下代码将为文档的第一个 &lt;h2&gt; 元素添加背景颜色：**/document.querySelector(&quot;h2, h3&quot;).style.backgroundColor = &quot;red&quot;;</code></pre><h3 id="获取元素总结"><a href="#获取元素总结" class="headerlink" title="获取元素总结"></a>获取元素总结</h3><ul><li>一份文档就是一颗节点树</li><li>节点分为不同类型：元素节点，属性节点，文本节点</li><li>getElementById()返回一个对象，该对象对应着文档里的一个特定的元素节点</li><li>getElementsByTagName()和getElementsByClassName()都返回的是一个数组对象，他们分别对应着一组特定的元素节点。</li><li>每个节点都是一个对象</li><li>querySelector()可以通过css选择器，属性选择器，元素标签获取元素，返回一个特定的元素节点，拥有多个同样元素节点的只返回第一个。</li><li>querySelectorAll()返回的是一个数组对象，对应一组特定的元素节点</li></ul><h2 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h2><h3 id="getAttribute-获取属性"><a href="#getAttribute-获取属性" class="headerlink" title="getAttribute()获取属性"></a>getAttribute()获取属性</h3><pre><code class="js">Object.getAttribute(attribute)</code></pre><h3 id="setAttribute-修改元素节点的属性值"><a href="#setAttribute-修改元素节点的属性值" class="headerlink" title="setAttribute()修改元素节点的属性值"></a>setAttribute()修改元素节点的属性值</h3><p>备注：这个方法有两个参数，第一个参数是要修改的属性名，第二个是要修改的值。</p><pre><code class="js">Object.setAttribute(&quot;属相名&quot;, &quot;值&quot;)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>getElementById()    返回一个特定元素节点对象<br>getElementsByTagName()<br>getElementsByClassName()   这两个返回一组特定的数组对象<br>getAttribute()  获取属性值<br>setAttribute()  修改属性值，设置属性和值<br>querySelector() 可以通过css选择器、元素、属性获取元素，多个返回第一个<br>querySelectorAll()返回一组特定的数组对象</p><h1 id="BOM知识点"><a href="#BOM知识点" class="headerlink" title="BOM知识点"></a>BOM知识点</h1><h2 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h2><p>BOM（Browser Object Model）是浏览器对象模型，是由浏览器厂商定义的 JavaScript API 集合。BOM 可以让开发者通过 JavaScript 操作浏览器窗口和框架等浏览器相关的对象，比如 window、location、history、navigator 等对象。</p><ul><li>和DOM的区别？<br>DOM（Document Object Model）是文档对象模型，是用来描述 HTML 或 XML 文档结构的编程接口，提供了一种可操作和访问文档内容和结构的方法。DOM 主要针对文档的内容和结构进行操作，而 BOM 主要针对浏览器窗口和框架进行操作。<strong>在 DOM 和 BOM 中，最重要的对象分别是 document 和 window。</strong></li></ul><h2 id="window对象常用事件"><a href="#window对象常用事件" class="headerlink" title="window对象常用事件"></a>window对象常用事件</h2><h3 id="窗口加载事件"><a href="#窗口加载事件" class="headerlink" title="窗口加载事件"></a>窗口加载事件</h3><p>(1) 窗口加载<br>window.onload &#x3D; function() {}或window.addEventListener(“load”,function() {})在浏览器窗口完全加载页面时触发 load 事件，可以将需要等到页面完全加载后才执行的代码放在 load 事件中，比如操作 DOM 节点等。</p><pre><code class="js">window.onload = function() &#123;  // 页面完全加载后执行的代码&#125;;</code></pre><p>注：通过onload事件可以直接将JavaScript代码写在页面元素前面，只需使JavaScript代码在load事件后执行即可。<br>(2)DOM内容加载</p><pre><code class="js">document.addEventListener(&#39;DOMContentLoaded&#39;,function() &#123;&#125;)只加载DOM内容，不包括样式表、图片等等。(如果页面内容较多，建议使用DOMContentLoaded，免得javascript内容半天加载不出来)document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;// DOM内容完全加载后执行的代码&#125;)</code></pre><h3 id="调整窗口大小事件"><a href="#调整窗口大小事件" class="headerlink" title="调整窗口大小事件"></a>调整窗口大小事件</h3><p>在浏览器窗口大小发生改变时触发 resize 事件，可以通过 resize 事件调整页面布局。</p><pre><code class="js">window.onresize = function() &#123;  // 调整窗口大小后执行的代码&#125;;</code></pre><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>(1).设置定时器<br>setInterval() 和 setTimeout() 是常用的定时器方法，可以用来定时执行 JavaScript 代码。</p><pre><code class="js">// 每隔 1 秒执行一次setInterval(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 1000);// 2 秒后执行一次setTimeout(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 2000);</code></pre><p>(2)清除定时器<br>可以通过 clearInterval() 和 clearTimeout() 方法来停止定时器。</p><pre><code class="js">var a = setInterval(function() &#123;  console.log(&#39;Hello World!&#39;);&#125;, 1000);// 清除定时器clearInterval(a);</code></pre><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><ul><li>概念： location属性用于获得<strong>当前窗口中加载的文档有关的信息</strong>或者设置窗体的URL，并且可以解析URL，因为返回的是一个对象，因此可以叫做location对象，还有一些导航功能，值得注意的是location既是window对象的属性，又是document对象的属性，既window.location和document.location 引用的是同一个对象。</li><li>URL: Uniform Resource Locator 统一资源定位符 :是互联网上标准的地址。互联网上的每个文件都有唯一的URL，包含 通过地址属性可以得到不同的url的信息图片location对象的属性</li></ul><pre><code class="js">location.href = “http://www.666.com”; //页面跳转到该网址location.assign(“http://www.666.com”); //页面跳转到该网址location.hash用于设置页面的标签值</code></pre><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><ul><li>概念：该对象里面保存着浏览器的各种信息，判断浏览器的各种信息就是从该对象里的属性来读取，具体属性如下</li></ul><pre><code class="js">navigator.cookicEnablcd:判断是否启用cookicnavigator.userAgent:判断浏览器的名称和版本号navigator.plugins:保存浏览器中所有插件信息的集合</code></pre><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><ul><li>概念：该对象保存着用户上网的历史记录，从窗口被打开的那一刻算起</li></ul><pre><code class="js">1.前进：history.forward();history.go(1);2.后退：history.back();history.go(-1);3.获取记录个数：history.length:</code></pre><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h2 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h2><p>参考：<a href="https://blog.csdn.net/Mozarty/article/details/130476224#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFBOM%201%20BOM%E6%A6%82%E8%BF%B0%20BOM%EF%BC%88Browser%20Object%20Model%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%82%E5%95%86%E5%AE%9A%E4%B9%89%E7%9A%84%20JavaScript%20API,%E5%9C%A8%20DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%EF%BC%8C%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E5%88%AB%E6%98%AF%20document%20%E5%92%8C%20window%E3%80%82">https://blog.csdn.net/Mozarty/article/details/130476224#:~:text=%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFBOM%201%20BOM%E6%A6%82%E8%BF%B0%20BOM%EF%BC%88Browser%20Object%20Model%EF%BC%89%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%98%AF%E7%94%B1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%82%E5%95%86%E5%AE%9A%E4%B9%89%E7%9A%84%20JavaScript%20API,%E5%9C%A8%20DOM%20%E5%92%8C%20BOM%20%E4%B8%AD%EF%BC%8C%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%86%E5%88%AB%E6%98%AF%20document%20%E5%92%8C%20window%E3%80%82</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DOM知识点&quot;&gt;&lt;a href=&quot;#DOM知识点&quot; class=&quot;headerlink&quot; title=&quot;DOM知识点&quot;&gt;&lt;/a&gt;DOM知识点&lt;/h1&gt;&lt;h2 id=&quot;DOM概念&quot;&gt;&lt;a href=&quot;#DOM概念&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="DOM" scheme="http://example.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>vue学习笔记</title>
    <link href="http://example.com/2023/10/30/vue/"/>
    <id>http://example.com/2023/10/30/vue/</id>
    <published>2023-10-30T11:57:56.358Z</published>
    <updated>2023-11-22T13:16:08.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue学习笔记"><a href="#vue学习笔记" class="headerlink" title="vue学习笔记"></a>vue学习笔记</h1><h2 id="初识vue"><a href="#初识vue" class="headerlink" title="初识vue"></a>初识vue</h2><ul><li>想让vue工作，必须创建一个<strong>vue实例</strong>，且要传入一个配置对象；</li><li>root容器里的代码依然符号html规范，只不过混入一个特殊的vue语法</li><li>root容器里的代码被称为【vue模板】</li><li>真实开发中只有<strong>一个</strong>vue实例，并且会配合组件一起使用；</li><li>vue实例和容器是一一对应的</li><li>中的xxx要写js的表达式，且xxx可以自动读取到data中的所有属性；</li><li>一旦data中的数据发生改变，那么页面中用到的数据地方会自动更新 </li><li>注意区分js表达式和js代码（语句）<br>1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<br>（1）a<br>（2）a+b<br>（3）demo（1）<br>（4）x&#x3D;&#x3D;&#x3D;y？‘a’：‘b’<br>2.js代码&#x2F;js语句<br>（1）if（）{}<br>（2）for（）{}</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;初始vue&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;Hello,&#123;&#123;name&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        //创建vue实例        new Vue(&#123;            el: &#39;#root&#39;,//el用于指定当前vue实例为哪个容器服务，植通常为css选择器字符串。            data: &#123;//data用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象                name: &#39;尚硅谷123&#39;,                address: &#39;深圳&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="两类模板语法"><a href="#两类模板语法" class="headerlink" title="两类模板语法"></a>两类模板语法</h2><ul><li>插值语法：</li></ul><p>功能：用于解析标签体的内容</p><p>写法，xxx是js的表达式，且可以直接读取到data中的所有属性</p><ul><li>指令语法</li></ul><p>功能：用于解析标签（包括：标签属性，标签体内容，绑定事件。。。）</p><p>举例：v-bind：herf&#x3D;“xxx”或 简写为 ：herf&#x3D;“xxx”，xxx同样为js的表达式且可以直接读取到data中的所有属性。</p><p>备注：vue有很多指令，且都有v-…的形式</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;vue模板&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;插值语法&lt;/h1&gt;        &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt;        &lt;hr /&gt;        &lt;h1&gt;指令语法&lt;/h1&gt;        &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;        &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;jack&#39;,                school: &#123;                    name: &#39;尚硅谷&#39;,                    url: &#39;http://www.atguigu.com&#39;,                &#125;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="数据绑定-2种方式"><a href="#数据绑定-2种方式" class="headerlink" title="数据绑定-2种方式"></a>数据绑定-2种方式</h2><p>1，单项数据绑定 v-bind<br>数据只能从data里面流向页面<br><img src="/pic/vue_1.png" alt="v-bind" title="v-bind"><br>2，双向数据绑定 v-model<br>数据不仅能从data流向页面，还可以从页面流向data</p><p>备注：：<br>1，双向绑定一般都引用在表单类元素上（如：input，select等）<br>2，v-model：value可以简写为v-model，因为v-model默认收集的就是value的值<br><img src="/pic/vue_2.png" alt="v-model" title="v-model"><br>3.v-bind：value简写为：value<br>4. v-model :value&#x3D;”name简写为v-model&#x3D;”name”</p><pre><code class="js">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        单项数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br /&gt;        双项数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br /&gt;           &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;尚硅谷&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="el和data的两种写法"><a href="#el和data的两种写法" class="headerlink" title="el和data的两种写法"></a>el和data的两种写法</h2><p>1，el的两种写法<br>（1）new Vue时候配置el属性。<br>（2）先创建Vue实例，随后再通过vm.$mount（‘#root’）指定el的值。<br>2，data有两种写法<br>（1）对象式<br>（2）函数式<br>如何选择：组件时必须使用函数式<br>3.重要原则<br>由vue管理的函数，一定不能写箭头函数，一旦写了箭头函数，this就不是vue实例了</p><pre><code class="js">&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;&lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示//el的两种写法const v = new Vue(&#123;    el:&#39;#root&#39;,//第一种    data:&#123;        name:&#39;shangguigu&#39;    &#125;&#125;)console.log(v)v.$mount(&#39;#root&#39;)//第二种    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>MVVM模型<br>1，M：模型model，data中的数据<br>2，V：视图view，模板代码<br>3，VM：视图模型viewmodel，vue实例<br>观察发现<br>1，data上的说有属性，最后都出现在vm上<br>2，vm身上的所有属性，以及vue原型上的说有属性，在vue模板中都可以直接使用</p><pre><code class="js">&lt;body&gt;    &lt;!-- 准备好一个容器 --&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h1&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h1&gt;        &lt;h1&gt;测试一下：&#123;&#123;_c&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        const vm = new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;尚硅谷&#39;,                address: &#39;beijing&#39;,                a: 1            &#125;        &#125;)        console.log(vm);    &lt;/script&gt;</code></pre><p><img src="/pic/vue_3.png" alt="MVVM" title="MVVM"></p><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p>1，vue中的数据代理<br>通过vm对象来代理data对象中属性的操作（读&#x2F;写）<br>2，基本原理<br>通过object。defineProperty()把对象中所有属性添加到vm上<br>为每一个添加到vm上的属性，都指定一个getter&#x2F;setter<br>在getter&#x2F;setter内部去操作（读&#x2F;写）data中对应的属性<br><img src="/pic/vue_4.png" alt="数据代理" title="数据代理"><br><img src="/pic/vue_5.png" alt="MVVM" title="数据代理"></p><pre><code class="js">1，    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        let number = 18        let person = &#123;            name: &#39;张三&#39;,            sex: &#39;男&#39;,        &#125;        Object.defineProperty(person, &#39;age&#39;, &#123;            value: 18,            enumerable: true,            writable: true,            configurable: true,            get() &#123;                console.log(&#39;有人读取了age属性了&#39;)                return number            &#125;,            set() &#123;                console.log(&#39;有人修改了age属性，且值式&#39;, value);                number = value            &#125;        &#125;)    &lt;/script&gt;2， &lt;!-- 数据代理：通过一个对象代理对另一个对象中的属性的操作 --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false//设置为 false 以阻止 vue 在启动时生成生产提示        let obj = &#123; x: 100 &#125;        let obj2 = &#123; y: 200 &#125;        Object.defineProperty(obj2, &#39;x&#39;, &#123;            get() &#123;                return obj.x            &#125;,            set(value) &#123;                obj.x = value            &#125;        &#125;)    &lt;/script&gt;3，&lt;body&gt;    &lt;div id=&quot;root&quot;&gt;        &lt;h2&gt;学校名称:&#123;&#123;name&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址:&#123;&#123;address&#125;&#125;&lt;/h2&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        Vue.config.productionTip = false        const vm = new Vue(&#123;            el: &#39;#root&#39;,            data: &#123;                name: &#39;atguigu&#39;,                address: &#39;jkdjhg&#39;            &#125;        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue学习笔记&quot;&gt;&lt;a href=&quot;#vue学习笔记&quot; class=&quot;headerlink&quot; title=&quot;vue学习笔记&quot;&gt;&lt;/a&gt;vue学习笔记&lt;/h1&gt;&lt;h2 id=&quot;初识vue&quot;&gt;&lt;a href=&quot;#初识vue&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Web前端篇（1）</title>
    <link href="http://example.com/2023/10/27/study/"/>
    <id>http://example.com/2023/10/27/study/</id>
    <published>2023-10-27T05:08:02.221Z</published>
    <updated>2023-11-13T13:00:50.522Z</updated>
    
    <content type="html"><![CDATA[<p>嗨~这里是在网上找到的一些资料或者b站视频后整理的一些知识点，接下来会不断更新…<br>…</p><h3 id="css高频"><a href="#css高频" class="headerlink" title="css高频"></a>css高频</h3><h4 id="快速居中对齐的方式有："><a href="#快速居中对齐的方式有：" class="headerlink" title="快速居中对齐的方式有："></a>快速居中对齐的方式有：</h4><pre><code class="html">&lt;style&gt;.box&#123;display：flex;margin：auto;&#125;&lt;/style&gt;</code></pre><h4 id="margin和padding有什么不同？"><a href="#margin和padding有什么不同？" class="headerlink" title="margin和padding有什么不同？"></a>margin和padding有什么不同？</h4><p>padding是内边距，是作用于自身的，而margin是作用于外部的</p><h4 id="vw和百分比的区别？"><a href="#vw和百分比的区别？" class="headerlink" title="vw和百分比的区别？"></a>vw和百分比的区别？</h4><p>百分比有继承关系<br>vw不管父级，只和视口有关</p><h4 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>行内元素不换行，不设置大小，大小由内容决定</p><h4 id="如何让谷歌浏览器支持小字体？"><a href="#如何让谷歌浏览器支持小字体？" class="headerlink" title="如何让谷歌浏览器支持小字体？"></a>如何让谷歌浏览器支持小字体？</h4><p>通过缩放把他字体改成多少倍</p><pre><code class="css">.box&#123;transform：scale(0.8)-webkit-transform:scale(0.8)&#125;</code></pre><h4 id="css的盒子模型"><a href="#css的盒子模型" class="headerlink" title="css的盒子模型"></a>css的盒子模型</h4><p>标准盒模型（W3C）：box-sizeing：content-box（默认值）<br>标准盒模型总宽度&#x2F;高度：margin+border+padding+内容区宽度&#x2F;高度（ 即 width&#x2F;height 不包含 padding 和 border 值 ））<br>怪异盒模型（IE盒模型)：box-sizing:border-box<br>标准盒模型总宽度&#x2F;高度：margin+ (内容区宽度&#x2F;高度 + padding + border) （ 即 width&#x2F;height 包含 padding 和 border 值 ））</p><h3 id="js高频"><a href="#js高频" class="headerlink" title="js高频"></a>js高频</h3><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><p><strong>改变原数组：</strong><br>1.pop():用于删除数组的最后一个元素<br>2.push():向数组的末尾添加一个或多个元素，并返回新的长度<br>3.shift():把数组第一个元素从其中删除，并返回第一个元素的值<br>4.unshift():向数组开头添加一个或者多个元素，并返回新长度<br>5.sort():排序<br>6.splice():添加或者删除数组中的元素<br>7.reverse():反转数组中的元素顺序<br>8.fill():讲一个固定值替换数组的元素<br>9.copeWithin():将数组元素复制到数组的另一个位置，覆盖现有值<br><strong>不改变原数组：</strong><br>一、返回新的数组<br>1.slice(): 可从已有的数组中返回选定的元素。slice 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<br>2.join():将数组作为字符串返回<br>3.toString（）：返回包含所有数组值的字符串，以逗号分隔<br>4.concat(): 用于连接两个或多个字符串。该方法没有改变原有字符串，但是会返回连接两个或多个的新数组。<br>二、返回值<br>1.indexof(): 可返回某个指定的字符串值在字符串中首次出现的位置<br>2.lastindexOf(): 可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索<br>3.include(): 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。<br><strong>遍历方法</strong><br>一、有返回值<br>1.map(): 通过指定函数处理数组的每个元素，并返回处理后的数组。<br>2.filter(): 检测数值元素，并返回符合条件所有元素的数组。<br>3.every(): 检测数值元素的每人元素是否都符合条件。<br>4.some(): 检测数组元素中是否有元素符合指定条件。<br>二、没有返回值<br>1.forEach (): 数组每个元素都执行一次回调函数。</p><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><p>1.concat()方法用于连接两个或多个字符串，该方法没有改变原有字符串，但是会返回连接两个或多个字符电新字符串<br>2.split(“”)字符串转数组<br>3.from()方法用于通过拥有length 属性的对象或可迭代的对象来返回一个数组。<br>4.slice(起始，结束) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。不会改变原始字符串<br>5.charAt()方法可返回指定位置的字符，返回值是字符串(从0开始)<br>6.replaceAll(被替换，替换）方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串<br>7.indexof()返回一个指定的字符审值最开始出现的位置，如果指定第二个参数 stat，则在一个字符串中的指定位置从前向后搜索<br>8.lastndexOf()方法可返回一个指定的字符串值最后出现的位置，如果指定第二个参数 stat，则在一个字符串中的指定位置从后向前搜索，<br>9.substr()方法可在字符串中抽取从开始下标开始的指定数目的字符。<br>10.fromCharCode(65)A将 Unicode 编码转为一个字符:<br>11.toupperCase()用于把字符串转换为大写<br>12.toLowerCase()方法用于把字符串转换为小写。</p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>1obiect.freeze（）冻结对象，被冻结的对象再也不能被修改(不能添加、删除属性，冻结一个对象后的原型也不能被修改<br>2.object.getOwnropertyNames()返回一个数组，其中包含作为参数传递的对象自身属性的所有名称，包括不可枚举属性。不考虑继承属性<br>3.object.keys()获取成员是参数对象自身的(不含继承的)所有可遍历(enumerable) 属性的键名，传入对象返数组形式的属性名，数组和字符审返回对应的索引值<br>4.object.values方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable) 属性的键值，返回一个数组，其元素是在对象上找到的可枚至属性值 (value) 属性的顺序与通过手动循环对象的属性值所给出的顺序相同var obj &#x3D;{0: ‘a’ ，1:‘b’， 2 ：‘C’}；consle.log(obiectvalues obj));<br>5.Object.entries方法返回一个数组，成员是参数对象自身的(不合继承的)所有可遍历(enumerable)属性的键值对数组,obiect.assign是ES6新添加的接口，主要的用途是用来合并多个JavaScript的对象，等同于扩展运算符。<br>6.Obiect对象的definePropertv属性标识<br>7.Object.getPrototype方法用来获取指定对象的原型<br>8.object.is()判断两值是否相同</p><h4 id="…args-扩展运算符"><a href="#…args-扩展运算符" class="headerlink" title="…args 扩展运算符"></a>…args 扩展运算符</h4><p>展开运算：允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。</p><h4 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h4><p> -Var<br>1）声明提升：先用后定义，无报错（（先上车后买票<br>2）没有局部作用域：在for循环之外仍可以（（红杏出墙<br>3）声明覆盖：同一个变量名被二次定义后，前面那个会被覆盖（let不行（（套牌车</p><pre><code class="js">let arr = [1,2,3]function test(a,b,c)&#123;&#125;test(..arr) //将数组展开进行传递参数</code></pre><p>数组中使用展开运算符(合并数组，类数组对象变成数组)</p><pre><code class="js">a.合并数组let arr = [1,2,3]let arr1 = [...arr,4,5,6]  //1,2,3,4,5,6</code></pre><pre><code class="js">b.展开运算符可以用于数组的一些方法中（push函数）let arr = [1,2,3]let arr1 = [4,5,6]arr1.push(...arr) //4,5,6,1,2,3</code></pre><pre><code class="js">c.类数组对象变成数组let a=new Set([1,2,3,4,5,2,1])  // a : Set(5) &#123;1, 2, 3, 4, 5&#125;let b=[...a]    //  (5) [1, 2, 3, 4, 5]</code></pre><p>3.解构赋值（解构赋值中展开运算符只能用在最后）</p><pre><code class="js">let [arg1,arg2,...arg3] = [1, 2, 3, 4] arg1 //1arg2 //2arg3 //[&#39;3&#39;,&#39;4&#39;]</code></pre><p>4.对象中的展开运算符（和数组类似）</p><pre><code class="js">let &#123;x,y,...z&#125;=&#123;x:1,y:2,a:3,b:4&#125;;x; //1y; //2z; //&#123;a:3,b:4&#125;</code></pre><pre><code class="js">let z=&#123;a:3,b:4&#125;;let n=&#123;x:1,y:2,...z&#125;;n; //&#123;x:1,y:2,a:3,b:4&#125;</code></pre><pre><code class="js">let a=&#123;x:1,y:2&#125;;let b=&#123;z:3&#125;;let ab=&#123;...a,...b&#125;;ab //&#123;x:1,y:2,z:3&#125;</code></pre><p><strong>剩余参数：</strong>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。<br>1.函数调用</p><pre><code class="js">function test(a,b,...args)&#123;&#125; //...args == [4,5,6]test(1,2,3,4,5,6)</code></pre><p>2.解构赋值（解构赋值中展开运算符只能用在最后）</p><pre><code class="js">let [arg1,arg2,...arg3] = [1, 2, 3, 4] arg1 //1arg2 //2arg3 //[&#39;3&#39;,&#39;4&#39;]</code></pre><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li>什么是浅拷贝？<br>特点：拷贝的时候只是拷贝了一份引用，修改拷贝以后的数据会影响原来的数据。<br>浅拷贝只是拷贝一层，更深层次对象级别的值拷贝引用<br>如何浅拷贝：1.直接赋值 2.遍历赋值 3.ES6的语法糖，object.assign(给谁，拷贝谁）只要一层就没有问题</li><li>深拷贝（深度克隆）？<br>特点：拷贝的时候会生成一份新的数据，修改拷贝以后的数据不会原数据。<br>拷贝多层，每一层的数据都会拷贝</li></ul><h5 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h5><p>基本数据类型没有深浅拷贝之说，一定要讲<strong>基本数据类型</strong>就是是<strong>深拷贝</strong></p><pre><code class="js">let a=5;let b=a;b=3;console.log(a,b)</code></pre><h6 id="下面这种newArr会不会改变arr"><a href="#下面这种newArr会不会改变arr" class="headerlink" title="下面这种newArr会不会改变arr?"></a>下面这种newArr会不会改变arr?</h6><pre><code class="js">let arr = [1,2,3];let newArr =[...arr];newArr.push(4);console.log(arr, newArr)</code></pre><p><strong>会！浅拷贝</strong><br>数组与对象的赋值都叫做浅拷贝</p><h6 id="数组与对象的赋值都叫做浅拷贝"><a href="#数组与对象的赋值都叫做浅拷贝" class="headerlink" title="数组与对象的赋值都叫做浅拷贝??"></a>数组与对象的赋值都叫做浅拷贝??</h6><pre><code class="JS">let arr2 = [[1,2,3], [4, 5, 6]];let newArr2 = [...arr2];newArr2[0].push(888);console.log(arr2, newArr2)</code></pre><p><strong>不会！解构赋值深拷贝</strong><br>解构赋值如果针对一维数组和对象，是深拷贝。</p><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><h5 id="props和emit"><a href="#props和emit" class="headerlink" title="props和emit"></a>props和emit</h5><p>子组件通过props选项来声明一个自定义的属性，然后父组件就可以在嵌套标签的时候，通过这个属性往子组件传递数据了。</p><pre><code class="js">&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是父组件！&lt;/h1&gt; &lt;child message=&quot;我是子组件一！&quot;&gt;&lt;/child&gt; //通过自定义属性传递数据 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &#39;../components/child.vue&#39;export default &#123; components: &#123;Child&#125;,&#125;&lt;/script&gt;</code></pre><pre><code class="js">&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&#39;message&#39;] //声明一个自定义的属性 &#125;&lt;/script&gt;</code></pre><h5 id="Ref和parent-children"><a href="#Ref和parent-children" class="headerlink" title="Ref和parent&#x2F;children"></a>Ref和parent&#x2F;children</h5><ul><li><p>如果ref用在子组件上，指向的是组件实例，可以理解为对子组件的索引，通过$ref可能获取到在子组件里定义的属性和方法。</p></li><li><p>如果ref在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，通过$ref可能获取到该DOM 的属性集合，轻松访问到DOM元素，作用与JQ选择器类似。</p></li></ul><pre><code class="js">&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是父组件！&lt;/h1&gt; &lt;child ref=&quot;msg&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from &#39;../components/child.vue&#39; export default &#123; components: &#123;Child&#125;, mounted: function () &#123;  console.log( this.$refs.msg);  this.$refs.msg.getMessage(&#39;我是子组件一！&#39;) &#125; &#125;&lt;/script&gt;</code></pre><pre><code class="js">&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data()&#123;  return&#123;  message:&#39;&#39;  &#125; &#125;, methods:&#123;  getMessage(m)&#123;  this.message=m;  &#125; &#125; &#125;&lt;/script&gt;</code></pre><p>从上面的代码我们可以发现，通过ref&#x3D;‘msg’可以将子组件child的实例指给ref，并且通过.msg.getMessage（）调用到子组件的getMessage方法，将参数传递给子组件。<br>prop和ref之间的区别：<br>prop 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。<br>$ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。</p><h5 id="eventBus-兄弟、父子组件通信"><a href="#eventBus-兄弟、父子组件通信" class="headerlink" title="eventBus 兄弟、父子组件通信"></a>eventBus 兄弟、父子组件通信</h5><h5 id="attrs-listeners-隔代通信"><a href="#attrs-listeners-隔代通信" class="headerlink" title="$attrs\listeners 隔代通信"></a>$attrs\listeners 隔代通信</h5><p>$attrs的使用 vue<br>$attrs是在vue的2.40版本以上添加的。<br>项目中有多层组件传参可以使用$attrs，可以使代码更加美观，更加简洁，维护代码的时候更方便。如果使用普通的父子组件传参prop和$emit，$on会很繁琐；如果使用vuex会大材小用，只是在这几个组件中使用，没必要使用vuex；使用事件总线eventBus，使用不恰当的话，有可能会出现事件多次执行。<br>如果给组件传递的数据，组件不使用props接收，那么这些数据将作为组件的HTML元素的特性，这些特性绑定在组件的HTML根元素上<br>inheritAttrs: false的含义是不希望本组件的根元素继承父组件的attribute，同时父组件传过来的属性（没有被子组件的props接收的属性），也不会显示在子组件的dom元素上，但是在组件里可以通过其$attrs可以获取到没有使用的注册属性, <code>inheritAttrs: false</code>是不会影响 style 和 class 的绑定<br>1）父组件的代码:给子组件关联数据，子组件如果不用props接收，那么这些数据就作为普通的HTML特性应用在子组件的根元素上</p><pre><code class="js">&lt;template&gt;  &lt;div&gt;    &lt;el-table :data=&#39;list&#39;&gt;      &lt;el-table-column        prop=&quot;name&quot;        label=&quot;姓名&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column        prop=&quot;study&quot;        label=&quot;学习科目&quot;      &gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;操作&quot;&gt;        &lt;template slot-scope=&quot;scope&quot;&gt;          &lt;el-button @click=&#39;transmitClick(scope.row)&#39;&gt;传递&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;        &lt;!-- 儿子组件 --&gt;    &lt;ChildView      :is-show=&quot;isOpen&quot;      :row=&quot;row&quot;    &gt;    &lt;/ChildView&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildView from &#39;./Child.vue&#39;export default &#123;  components: &#123; ChildView &#125;,  data() &#123;    return &#123;      isOpen: false,      row: &#123;&#125;,      list: [        &#123; name: &#39;王丽&#39;, study: &#39;Java&#39; &#125;,        &#123; name: &#39;李克&#39;, study: &#39;Python&#39; &#125;      ]    &#125;  &#125;,  methods: &#123;    // 传递事件    transmitClick(row) &#123;      this.isOpen = true;      this.row = row    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>2)儿子组件，中间层，作为父组件和孙子组件的传递中介，在儿子组件中给孙子组件添加v-bind&#x3D;”$attrs”，这样孙子组件才能接收到数据</p><pre><code class="js">&lt;template&gt;  &lt;div class=&#39;child-view&#39;&gt;    &lt;p&gt;儿子组件&lt;/p&gt;    &lt;GrandChild v-bind=&quot;$attrs&quot;&gt;&lt;/GrandChild&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandChild from &#39;./GrandChild.vue&#39;export default &#123;  // 继承所有父组件的内容  inheritAttrs: true,  components: &#123; GrandChild &#125;,  data() &#123;    return &#123;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt;.child-view &#123;  margin: 20px  border: 2px solid red  padding: 20px&#125;&lt;/style&gt;</code></pre><p>3)孙子组件：在孙子组件中一定要使用props接收从父组件传递过来的数据</p><pre><code class="js">&lt;template&gt;  &lt;div class=&#39;grand-child-view&#39;&gt;    &lt;p&gt;孙子组件&lt;/p&gt;    &lt;p&gt;传给孙子组件的数据：&#123;&#123;row.name&#125;&#125; &#123;&#123;row.name !== undefined? '学习' : ''&#125;&#125; &#123;&#123;row.study&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  // 不想继承所有父组件的内容,同时也不在组件根元素dom上显示属性  inheritAttrs: false,  // 在本组件中需要接收从父组件传递过来的数据，注意props里的参数名称不能改变，必须和父组件传递过来的是一样的  props: &#123;    isShow: &#123;      type: Boolean,      dedault: false    &#125;,    row: &#123;      type: Object,      dedault: () =&gt; &#123; &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt;.grand-child-view &#123;  border: 2px solid green  padding: 20px  margin: 20px&#125;&lt;/style&gt;</code></pre><h5 id="Provide-inject-隔代组件通信"><a href="#Provide-inject-隔代组件通信" class="headerlink" title="Provide\inject 隔代组件通信"></a>Provide\inject 隔代组件通信</h5><p>6、Vuex<br>7、Pubsub库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嗨~这里是在网上找到的一些资料或者b站视频后整理的一些知识点，接下来会不断更新…&lt;br&gt;…&lt;/p&gt;
&lt;h3 id=&quot;css高频&quot;&gt;&lt;a href=&quot;#css高频&quot; class=&quot;headerlink&quot; title=&quot;css高频&quot;&gt;&lt;/a&gt;css高频&lt;/h3&gt;&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="html" scheme="http://example.com/tags/html/"/>
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Alice&#39;s First Blog</title>
    <link href="http://example.com/2023/10/26/firstBlog/"/>
    <id>http://example.com/2023/10/26/firstBlog/</id>
    <published>2023-10-26T14:20:39.271Z</published>
    <updated>2023-11-01T02:56:13.596Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎你来到我的博客网站！这是我的一方小天地呀~</p><p>这里将会记录我的学习和知识…</p><h3 id="搭建bolg资料和网站"><a href="#搭建bolg资料和网站" class="headerlink" title="搭建bolg资料和网站"></a>搭建bolg资料和网站</h3><p>在线md： <a href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a><br>Butterfly 主题的详细配置：<br><a href="https://liangshenglei.github.io/2023/03/06/Butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/index.html">https://liangshenglei.github.io/2023/03/06/Butterfly%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/index.html</a><br>背景：<br>1.Hexo-Butterfly主题优化-设置网站首页显示背景、文章最上方不显示背景 <a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a><br>2. Butterfly主题优化首页大图加载效果 <a href="http://demian.wang/2021/06/05/Butterfly%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/">http://demian.wang/2021/06/05/Butterfly%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE%E5%8A%A0%E8%BD%BD%E6%95%88%E6%9E%9C/</a></p><p>分类以及标签页<br>1.Hexo使用攻略-添加分类及标签<a href="https://www.jianshu.com/p/e17711e44e00">https://www.jianshu.com/p/e17711e44e00</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎你来到我的博客网站！这是我的一方小天地呀~&lt;/p&gt;
&lt;p&gt;这里将会记录我的学习和知识…&lt;/p&gt;
&lt;h3 id=&quot;搭建bolg资料和网站&quot;&gt;&lt;a href=&quot;#搭建bolg资料和网站&quot; class=&quot;headerlink&quot; title=&quot;搭建bolg资料和网站&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="web前端" scheme="http://example.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo的基础配置</title>
    <link href="http://example.com/2023/10/26/hello-world/"/>
    <id>http://example.com/2023/10/26/hello-world/</id>
    <published>2023-10-26T11:42:54.873Z</published>
    <updated>2023-10-30T08:49:37.437Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
